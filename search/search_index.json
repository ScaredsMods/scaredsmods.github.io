{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Scaredsmods' documentation","text":"<p>This is the place you will find all documentations for every mod or plugin I have made. With this, I am aiming to provide the best documentation I possibly can for you to understand. Even if the mod / plugin is small, it will be documented anyways.</p>"},{"location":"#what-youll-find-here","title":"What you'll find here","text":"<ul> <li>Mod documentation</li> <li>Plugin documentation</li> </ul>"},{"location":"#go-to","title":"Go to","text":"<ul> <li>Mods</li> <li>Plugins</li> <li>Credits</li> </ul>"},{"location":"credits/","title":"Credits","text":""},{"location":"credits/#thanks-to","title":"Thanks to:","text":"<ul> <li>MkDocs for providing the documentation base</li> <li>Squidfunk / Material Theme for providing the theme for MkDocs</li> <li>Kody Simpson for making SubCommandLib possible</li> <li>Kaupenjoe for teaching me how to make minecraft mods in java and having such a wonderful support server.</li> </ul>"},{"location":"mods/","title":"All available mods","text":""},{"location":"mods/#standalone-mods","title":"Standalone mods","text":""},{"location":"mods/#library-and-api","title":"Library and API","text":""},{"location":"mods/#more-outputs-api","title":"More Outputs API","text":"<p>What is this mod? This mod is a small, but powerful library allowing developers to add recipes containing more than one output as vanilla source does not provide a way to do that. It consists of 3 classes, allowing for 2, 3 or 4 outputs. I might add more, but at some point it isnt worth it to add more.</p> To DO When Active Development Make it one class that allows all possible amounts of outputs Some time No <p>DISCLAIMER: I have only tested Kaupenjoe's way of registering custom Recipes. Other ways might work, but not ones I know of. I kindly ask to report other ways, bugs or issues to the github repository. Please use the correct lable depending on your report.</p>"},{"location":"mods/more-outputs-api/","title":"More Ouputs API","text":""},{"location":"mods/more-outputs-api/#very-big-disclaimer-this-tutorial-was-written-for-minecraft-1204-any-version-that-is-newer-will-not-work-im-currently-working-on-making-a-1205-tutorial-i-dont-know-how-long-this-will-take-stay-tuned-and-read-well","title":"VERY BIG DISCLAIMER: This tutorial was written for Minecraft 1.20.4, ANY VERSION THAT IS NEWER WILL NOT WORK. Im currently working on making a 1.20.5+ tutorial, I don't know how long this will take, stay tuned and read well.","text":""},{"location":"mods/more-outputs-api/#version-scheme-for-more-outputs-api","title":"Version scheme for More Outputs API","text":"<p>Note: it isnt worth backporting to version prior to 1.18 and certainly not prior to 1.14 so those versions won't be backported. Where <code>x</code> stands for the update of the mod &amp; <code>y</code> stands for minecraft version suffix like 1.20.1. Note that <code>z</code> only appears when there is an actual bugfix, otherwise it will be for example <code>2.x.y</code>. </p> Minecraft Version Mod Version Mod Loader Status &lt; 1.18 - Fabric skipped 1.18.x 0.2.y.z Fabric done 1.19.x 0.5.y.z Fabric done 1.20.x 1.x.y.z Fabric done 1.21.x 2.x.y.z Fabric current version <p>This mod is availabe on: </p> <p> </p> <p>and  on CurseForge</p> <p>Extra info on the mod such as download count can be found here</p>"},{"location":"mods/more-outputs-api/#getting-started","title":"Getting Started","text":"Gradle (Groovy)Maven <p>In your build.gradle<pre><code>// Should be in the TOP repositories block\nrepositories {\n    mavenCentral()\n\n    maven {\n        url = (\"https://repo.repsy.io/mvn/scaredrabbit/scaredsmods\")\n    }\n}\n//Dependencies block\nmodImplementation \"io.github.scaredsmods.moreoutputsapi:MoreOutputsAPI:${project.moapi_version}\"\n//OR \nmodApi \"io.github.scaredsmods.moreoutputsapi:MoreOutputsAPI:${project.moapi_version}\"\n</code></pre> In your gradle.properties<pre><code>moapi_version = VERSION\n</code></pre></p> <pre><code>&lt;!-- Should be in the &lt;repositories&gt;&lt;/repositories&gt; block --&gt;\n&lt;repository&gt;\n    &lt;id&gt;repsy&lt;/id&gt;\n    &lt;url&gt;https://repo.repsy.io/mvn/scaredrabbit/scaredsmods&lt;/url&gt;\n&lt;/repository&gt;\n\n&lt;!-- Should be in the &lt;dependencies&gt;&lt;/dependencies&gt; block --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.github.scaredsmods.moreoutputsapi&lt;/groupId&gt;\n    &lt;artifactId&gt;MoreOutputsAPI&lt;/artifactId&gt;\n    &lt;version&gt;VERSION&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p><code>VERSION</code> can either be found on curseforge or on repsy</p>"},{"location":"mods/more-outputs-api/#usage","title":"Usage","text":"<p>I would assume that you already know most of the things we are about to do, but for those that don't know, here is the tutorial!</p>"},{"location":"mods/more-outputs-api/#what-well-need","title":"What we'll need","text":"<ul> <li>A custom block</li> <li>A (custom) block entity</li> <li>A custom recipe of course</li> <li>A screen(handler) for the block entity</li> </ul>"},{"location":"mods/more-outputs-api/block/","title":"Block","text":"<p>Now we can create the <code>ModBlocks</code> class in the <code>block</code> package. For this to work, in your main class, in this case <code>ExampleMod</code> there should be a field like this: </p> <pre><code>public static final String MOD_ID = \"yourmodid\";\n</code></pre>"},{"location":"mods/more-outputs-api/block/#modblocks-class","title":"ModBlocks class","text":"<pre><code>public class ModBlocks {\n\n    public static final Block EXAMPLE_BLOCK = registerBlock(\"example_block\",\n        new ExampleBlock(FabricBlockSettings.copyOf(Blocks.IRON_BLOCK).nonOpaque())); // (1)!\n\n    private static Block registerBlock(String name, Block block) {\n        registerBlockItem(name, block);\n        return Registry.register(Registries.BLOCK, new Identifier(Main.MOD_ID, name), block);\n    }\n\n    private static Item registerBlockItem(String name, Block block) {\n        return Registry.register(Registries.ITEM, new Identifier(Main.MOD_ID, name),\n            new BlockItem(block, new FabricItemSettings()));\n    }\n\n    public static void registerModBlocks() {\n        ExampleMod.LOGGER.info(\"Registering ModBlocks for \" + ExampleMod.MOD_ID); // (2)!\n    }\n}\n</code></pre> <ol> <li>\u274c Here should be an error present, as we haven't made that class yet</li> <li>This method can be empty and is recommended for large projects</li> </ol> <p>As the names might suggest, <code>registerBlock()</code> and <code>registerBlockItem()</code> add the block the <code>registerBlock()</code> method is used on to the registry, by taking a name, a block and adding it as a block under your mod's modid.</p>"},{"location":"mods/more-outputs-api/block/#exampleblock-block-class","title":"ExampleBlock block class","text":"<p>You can call the classes and packages whatever you want, I will call them <code>block</code>, <code>block/entities</code> and <code>block/custom</code>. Start by creating a class I will call <code>ExampleBlock</code> in the <code>block/custom</code> package. That class should look something like this:</p> <pre><code>public class ExampleBlock extends BlockWithEntity implements BlockEntityProvider {\n    private static final VoxelShape SHAPE = Block.createCuboidShape(0, 0, 0, 16, 12, 16);\n\n    public static final MapCodec&lt;ExampleBlock&gt; CODEC = ExampleBlock.createCodec(ExampleBlock::new);\n\n    public ExampleBlock(Settings settings) {\n        super(settings);\n    }\n\n    @Override\n    protected MapCodec&lt;? extends BlockWithEntity&gt; getCodec() {\n        return CODEC;\n    }\n\n    @Override\n    public VoxelShape getOutlineShape(BlockState state, BlockView world, BlockPos pos, ShapeContext context) {\n        return SHAPE;\n    }\n\n    @Override\n    public BlockRenderType getRenderType(BlockState state) {\n        return BlockRenderType.MODEL;\n    }\n\n    @Nullable\n    @Override\n    public BlockEntity createBlockEntity(BlockPos pos, BlockState state) {\n        return new ExampleBlockEntity(pos, state); // (1)!\n    }\n\n    @Override\n    public void onStateReplaced(BlockState state, World world, BlockPos pos, BlockState newState, boolean moved) {\n        if (state.getBlock() != newState.getBlock()) {\n            BlockEntity blockEntity = world.getBlockEntity(pos);\n            if (blockEntity instanceof ExampleBlockEntity) { // (2)! \n                ItemScatterer.spawn(world, pos, (ExampleBlockEntity)blockEntity); // (3)!\n                world.updateComparators(pos,this);\n            }\n            super.onStateReplaced(state, world, pos, newState, moved);\n        }\n    }\n\n\n\n    @Override\n    public ActionResult onUse(BlockState state, World world, BlockPos pos, PlayerEntity player, Hand hand, BlockHitResult hit) {\n        if (!world.isClient) {\n            NamedScreenHandlerFactory screenHandlerFactory = ((ExampleBlockEntity) world.getBlockEntity(pos)); // (4)!\n\n            if (screenHandlerFactory != null) {\n                player.openHandledScreen(screenHandlerFactory);\n            }\n        }\n\n        return ActionResult.SUCCESS;\n    }\n\n    @Nullable\n    @Override\n    public &lt;T extends BlockEntity&gt; BlockEntityTicker&lt;T&gt; getTicker(World world, BlockState state, BlockEntityType&lt;T&gt; type) {\n        return validateTicker(type, ModBlockEntities.EXAMPLE_BLOCK_ENTITY, // (5)!\n                (world1, pos, state1, blockEntity) -&gt; blockEntity.tick(world1, pos, state1));\n    }\n}\n</code></pre> <ol> <li>\u274c Here should be an error present, as we haven't made that class yet</li> <li>\u274c Here should be an error present, as we haven't made that class yet</li> <li>\u274c Here should be an error present, as we haven't made that class yet</li> <li>\u274c Here should be an error present, as we haven't made that class yet</li> <li>\u274c Here should be an error present, as we haven't made that class yet</li> </ol>"},{"location":"mods/more-outputs-api/connecting/","title":"Connecting screen","text":""},{"location":"mods/more-outputs-api/connecting/#connecting-the-screen-to-the-client","title":"Connecting the screen to the client","text":""},{"location":"mods/more-outputs-api/connecting/#clientmodinitializer","title":"ClientModInitializer","text":"<p>To do this you need a class that implements <code>ClientModInitializer</code>, in my case <code>ExampleModClient</code>. Implement the <code>onClientInitialize()</code> method.</p> <p>The following line adds the screen from the client:</p> <pre><code>HandledScreens.register(ModScreenHandlers.EXAMPLE_SCREEN_HANDLER, ExampleScreen::new);\n</code></pre> <p>Full method:</p> <pre><code>@Override\npublic void onInitializeClient() {\n    [... Other client stuff ...]\n    HandledScreens.register(ModScreenHandlers.EXAMPLE_SCREEN_HANDLER, ExampleScreen::new);\n    [... Other client stuff ...]\n}\n</code></pre> <p>This is dependent on the <code>fabric.mod.json</code> file in <code>resources</code>. To let fabric know that this class exists, add this to your <code>fabric.mod.json</code> under the entrypoints section:</p> <pre><code>\"client\": [\n    \"your.path.to.ModClient\"\n]\n</code></pre>"},{"location":"mods/more-outputs-api/extra-info/","title":"Extra information for MO API","text":""},{"location":"mods/more-outputs-api/extra-info/#curseforge","title":"Curseforge","text":""},{"location":"mods/more-outputs-api/extra-info/#modrinth","title":"Modrinth","text":""},{"location":"mods/more-outputs-api/other-things/","title":"Other things you will need","text":"<ul> <li>A model</li> <li>An item model</li> <li>A blockstate</li> <li>Translations (Optional)</li> <li>A GUI Texture</li> <li>A block texture</li> </ul> <p>Note: This is the part that you have to make yourselves, as I can't make a fitting model for everyone.</p>"},{"location":"mods/more-outputs-api/registering/","title":"Registering","text":""},{"location":"mods/more-outputs-api/registering/#in-the-main-class","title":"In the main class...","text":"<p>In your main class, we have four things we need to register: The block, block entity, the recipe and the screenhandlers. To do this, go to your class that implements <code>ModInitializer</code>, go to <code>onInitialize()</code> and add this if you haven't already</p> <pre><code>@Override\npublic void onInitialize() {\n\n    ModBlockEntities.registerBlockEntities();\n    ModBlocks.registerModBlocks();\n    ModRecipes.registerRecipes();\n    ModScreenHandlers.registerScreenHandlers();\n}\n</code></pre>"},{"location":"mods/more-outputs-api/block-entity/","title":"Block entities","text":"<p>Before we can create our block entity, we need to first make 2 'helper' classes, <code>ModBlockEntities</code> and a little helper class <code>ImplementedInventory</code>. NOTE: I did not make the last class, all credits are available in that class.</p> ModBlockEntitiesImplementedInventory <pre><code>public class ModBlockEntities {\n\n    public static final BlockEntityType&lt;ExampleBlockEntity&gt; EXAMPLE_BLOCK_ENTITY =  // (1)\n        Registry.register(Registries.BLOCK_ENTITY_TYPE, Identifier.of(ExampleMod.MOD_ID, \"example_be\"),\n                BlockEntityType.Builder.create(ExampleBlockEntity::new,  // (2)\n                        ModBlocks.EXAMPLE_BLOCK).build());  // (3)\n\n    public static void registerBlockEntities() {\n        Main.LOGGER.info(\"Registering Block Entities for \" + Main.MOD_ID);\n    }\n}\n</code></pre> <ol> <li>\u274c Here should be an error present, as we haven't made that class yet</li> <li>\u274c Here should be an error present, as we haven't made that class yet</li> <li>\u274c Here should be an error present, as we haven't made that class yet</li> </ol> <pre><code>    /**\n     * A simple {@code SidedInventory} implementation with only default methods + an item list getter.\n     *\n     * &lt;h2&gt;Reading and writing to tags&lt;/h2&gt;\n     * Use {@link Inventories#writeNbt(NbtCompound, DefaultedList)} and {@link Inventories#readNbt(NbtCompound, DefaultedList)}\n     * on {@linkplain #getItems() the item list}.\n     *\n     * License: &lt;a href=\"https://creativecommons.org/publicdomain/zero/1.0/\"&gt;CC0&lt;/a&gt;\n     * @author Juuz\n     */\n    @FunctionalInterface\n    public interface ImplementedInventory extends SidedInventory {\n        /**\n         * Gets the item list of this inventory.\n         * Must return the same instance every time it's called.\n         *\n         * @return the item list\n         */\n        DefaultedList&lt;ItemStack&gt; getItems();\n\n        /**\n         * Creates an inventory from the item list.\n         *\n         * @param items the item list\n         * @return a new inventory\n         */\n        static ImplementedInventory of(DefaultedList&lt;ItemStack&gt; items) {\n            return () -&gt; items;\n        }\n\n        /**\n         * Creates a new inventory with the size.\n         *\n         * @param size the inventory size\n         * @return a new inventory\n         */\n        static ImplementedInventory ofSize(int size) {\n            return of(DefaultedList.ofSize(size, ItemStack.EMPTY));\n        }\n\n        // SidedInventory\n\n        /**\n         * Gets the available slots to automation on the side.\n         *\n         * &lt;p&gt;The default implementation returns an array of all slots.\n         *\n         * @param side the side\n         * @return the available slots\n         */\n        @Override\n        default int[] getAvailableSlots(Direction side) {\n            int[] result = new int[getItems().size()];\n            for (int i = 0; i &lt; result.length; i++) {\n                result[i] = i;\n            }\n\n            return result;\n        }\n\n        /**\n         * Returns true if the stack can be inserted in the slot at the side.\n         *\n         * &lt;p&gt;The default implementation returns true.\n         *\n         * @param slot the slot\n         * @param stack the stack\n         * @param side the side\n         * @return true if the stack can be inserted\n         */\n        @Override\n        default boolean canInsert(int slot, ItemStack stack, @Nullable Direction side) {\n            return true;\n        }\n\n        /**\n         * Returns true if the stack can be extracted from the slot at the side.\n         *\n         * &lt;p&gt;The default implementation returns true.\n         *\n         * @param slot the slot\n         * @param stack the stack\n         * @param side the side\n         * @return true if the stack can be extracted\n         */\n        @Override\n        default boolean canExtract(int slot, ItemStack stack, Direction side) {\n            return true;\n        }\n\n        // Inventory\n\n        /**\n         * Returns the inventory size.\n         *\n         * &lt;p&gt;The default implementation returns the size of {@link #getItems()}.\n         *\n         * @return the inventory size\n         */\n        @Override\n        default int size() {\n            return getItems().size();\n        }\n\n        /**\n         * @return true if this inventory has only empty stacks, false otherwise\n         */\n        @Override\n        default boolean isEmpty() {\n            for (int i = 0; i &lt; size(); i++) {\n                ItemStack stack = getStack(i);\n                if (!stack.isEmpty()) {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        /**\n         * Gets the item in the slot.\n         *\n         * @param slot the slot\n         * @return the item in the slot\n         */\n        @Override\n        default ItemStack getStack(int slot) {\n            return getItems().get(slot);\n        }\n\n        /**\n         * Takes a stack of the size from the slot.\n         *\n         * &lt;p&gt;(default implementation) If there are less items in the slot than what are requested,\n         * takes all items in that slot.\n         *\n         * @param slot the slot\n         * @param count the item count\n         * @return a stack\n         */\n        @Override\n        default ItemStack removeStack(int slot, int count) {\n            ItemStack result = Inventories.splitStack(getItems(), slot, count);\n            if (!result.isEmpty()) {\n                markDirty();\n            }\n\n            return result;\n        }\n\n        /**\n         * Removes the current stack in the {@code slot} and returns it.\n         *\n         * &lt;p&gt;The default implementation uses {@link Inventories#removeStack(List, int)}\n         *\n         * @param slot the slot\n         * @return the removed stack\n         */\n        @Override\n        default ItemStack removeStack(int slot) {\n            return Inventories.removeStack(getItems(), slot);\n        }\n\n        /**\n         * Replaces the current stack in the {@code slot} with the provided stack.\n         *\n         * &lt;p&gt;If the stack is too big for this inventory ({@link Inventory#getMaxCountPerStack()}),\n         * it gets resized to this inventory's maximum amount.\n         *\n         * @param slot the slot\n         * @param stack the stack\n         */\n        @Override\n        default void setStack(int slot, ItemStack stack) {\n            getItems().set(slot, stack);\n            if (stack.getCount() &gt; getMaxCountPerStack()) {\n                stack.setCount(getMaxCountPerStack());\n            }\n            markDirty();\n        }\n\n        /**\n         * Clears {@linkplain #getItems() the item list}}.\n         */\n        @Override\n        default void clear() {\n            getItems().clear();\n        }\n\n        @Override\n        default void markDirty() {\n            // Override if you want behavior.\n        }\n\n        @Override\n        default boolean canPlayerUse(PlayerEntity player) {\n            return true;\n        }\n    }\n</code></pre> <p>Now we can make a block entity with 2, 3 or 4 possible outputs.</p>"},{"location":"mods/more-outputs-api/block-entity/four-outputs/","title":"Block Entity with two output slots","text":"<p>To create a block entity with two output slots, create a new class in <code>net.example.yourmodid.block.entity</code>, the class extends <code>BlockEntity</code> and implements <code>ExtendedScreenHandlerFactory, ImplementedInventory</code></p> <p>In action, it would look like this:</p> <pre><code>public class ExampleBlockEntity extends BlockEntity implements ExtendedScreenHandlerFactory, ImplmentedInventory {\n\n\n}\n</code></pre>"},{"location":"mods/more-outputs-api/block-entity/four-outputs/#fields-constructor","title":"Fields &amp; constructor","text":"<p>Before we can make all the required methods, we need a few fields and a constructor.</p> <pre><code>private final DefaultedList&lt;ItemStack&gt; inventory = DefaultedList.ofSize(5, ItemStack.EMPTY);//(1)!\n\nprivate static final int INPUT_SLOT = 0;//(2)!\nprivate static final int OUTPUT_SLOT_1 = 1;//(3)!\nprivate static final int OUTPUT_SLOT_2 = 2;//(4)!\nprivate static final int OUTPUT_SLOT_3 = 3;//(5)!\nprivate static final int OUTPUT_SLOT_4 = 4;//(6)!\n\nprotected final PropertyDelegate propertyDelegate;\nprivate int progress = 0;//(7)!\nprivate int maxProgress = 100;//(8)!\n</code></pre> <ol> <li>IMPORTANT: This should be the total amount of slots in the block entity &amp; recipe. Including the input &amp; output slots</li> <li>This is the slot you put the item to be crafted in.</li> <li>This is the first output in the recipe</li> <li>This is the second output in the recipe</li> <li>This is the third output in the recipe</li> <li>This is the fourth output in the recipe</li> <li>At this point, the block entity (machine) starts crafting</li> <li>This is the max amount of time the crafting takes</li> </ol> <p>The constructor should look like this:</p> <pre><code>public ExampleBlockEntity(BlockPos pos, BlockState state) {\n    super(ModBlockEntities.EXAMPLE_BLOCK_ENTITY, pos, state);\n    this.propertyDelegate = new PropertyDelegate() {\n        @Override\n        public int get(int index) {\n            return switch (index) {\n                case 0 -&gt; ExampleBlockEntity.this.progress;\n                case 1 -&gt; ExampleBlockEntity.this.maxProgress;\n                default -&gt; 0;\n            };\n        }\n\n        @Override\n        public void set(int index, int value) {\n            switch (index) {\n                case 0 -&gt; ExampleBlockEntity.this.progress = value;\n                case 1 -&gt; ExampleBlockEntity.this.maxProgress = value;\n            }\n        }\n\n        @Override\n        public int size() {\n            return 5;//(1)!\n        }\n    };\n}\n</code></pre> <ol> <li>IMPORTANT: This should be the total amount of slots in the block entity &amp; recipe. Including the input &amp; output slots</li> </ol>"},{"location":"mods/more-outputs-api/block-entity/four-outputs/#required-methods","title":"Required methods","text":"<p>Now we can make all the required methods neccessary: </p> writeScreenOpeningData()<pre><code>@Override\npublic void writeScreenOpeningData(ServerPlayerEntity player, PacketByteBuf buf) {\n    buf.writeBlockPos(this.pos);\n}\n</code></pre> getDisplayName()<pre><code>@Override\npublic Text getDisplayName() {\n    return Text.literal(\"Example Block\");//(1)!\n}\n</code></pre> <ol> <li>I would recommend that you make this translatable by replacing <code>Text.literal()</code> with <code>Text.translatable</code> and adding a translation key and translate it in for example <code>nl_nl.json</code></li> </ol> getItems()<pre><code>@Override\npublic DefaultedList&lt;ItemStack&gt; getItems() {\n    return inventory;\n}\n</code></pre> readNbt() and writeNbt()<pre><code>@Override\npublic void writeNbt(NbtCompound nbt) {\n    super.writeNbt(nbt);\n    Inventories.writeNbt(nbt, inventory);\n    nbt.putInt(\"example_block.progress\", progress);//(1)!\n}\n\n@Override\npublic void readNbt(NbtCompound nbt) {\n    super.readNbt(nbt);\n    Inventories.readNbt(nbt, inventory);\n    progress = nbt.getInt(\"example_block.progress\");//(2)!\n}\n</code></pre> <ol> <li>These two strings should match!</li> <li>These two strings should match!</li> </ol> createMenu()<pre><code>@Nullable\n@Override\npublic ScreenHandler createMenu(int syncId, PlayerInventory playerInventory, PlayerEntity player) {\n    return new ExampleScreenHandler(syncId, playerInventory, this, this.propertyDelegate);//(1)!\n}\n</code></pre> <ol> <li>\u274c Error: Class not created</li> </ol> tick()<pre><code>public void tick(World world, BlockPos pos, BlockState state) {//(1)!\n    if(world.isClient()) {\n        return;\n    }\n\n\n    if(areOutputSlotsEmptyOreReceivable()) {\n        if(this.hasRecipe()) {\n            this.increaseCraftProgress();\n            markDirty(world, pos, state);\n\n            if(hasCraftingFinished()) {\n                this.craftItem();\n                this.resetProgress();\n            }\n        } else {\n            this.resetProgress();\n        }\n    } else {\n        this.resetProgress();\n        markDirty(world, pos, state);\n    }\n}\n</code></pre> <ol> <li>\u274c Here should be a few errors present, as we haven't made those methods yet</li> </ol> <p>Now we are going to make the methods that are going to have influence on how the <code>tick()</code> method above behaves. Im doing it from top to bottom, and the first method (or boolean) is:</p> <p>areOutputSlotsEmptyOrReceivable()<pre><code>private boolean areOutputsSlotEmptyOrReceivable() {\n    return (this.getStack(OUTPUT_SLOT_1).isEmpty() || this.getStack(OUTPUT_SLOT_1).getCount() &lt; this.getStack(OUTPUT_SLOT_1).getMaxCount())\n            &amp;&amp;\n            (this.getStack(OUTPUT_SLOT_2).isEmpty() || this.getStack(OUTPUT_SLOT_2).getCount() &lt; this.getStack(OUTPUT_SLOT_2).getMaxCount())\n            &amp;&amp; \n            (this.getStack(OUTPUT_SLOT_3).isEmpty() || this.getStack(OUTPUT_SLOT_3).getCount() &lt; this.getStack(OUTPUT_SLOT_3).getMaxCount())\n            &amp;&amp;\n            (this.getStack(OUTPUT_SLOT_4).isEmpty() || this.getStack(OUTPUT_SLOT_4).getCount() &lt; this.getStack(OUTPUT_SLOT_4).getMaxCount());\n}\n</code></pre> What we are doing here, is checking if the output slots are empty or in the case that there \u00eds an item in the slot, we check if the amount of items is smaller than 64 (<code>getMaxCount()</code>)</p> <p>Then, we check if the block entity has a recipe with <code>hasRecipe()</code> but before that methods, we need two other helper methods:</p> <p>canInsertItemIntoOutputSlots() &amp; canInsertAmountIntoOutputSlots()<pre><code>private boolean canInsertItemIntoOutputSlots(Item item, Item item2, Item item3, Item item4) {\n    return (this.getStack(OUTPUT_SLOT_1).getItem() == item || this.getStack(OUTPUT_SLOT_1).isEmpty()) &amp;&amp;\n        (this.getStack(OUTPUT_SLOT_2).getItem() == item2 || this.getStack(OUTPUT_SLOT_2).isEmpty()) &amp;&amp;\n        (this.getStack(OUTPUT_SLOT_3).getItem() == item3 || this.getStack(OUTPUT_SLOT_3).isEmpty()) &amp;&amp;\n        (this.getStack(OUTPUT_SLOT_4).getItem() == item4 || this.getStack(OUTPUT_SLOT_4).isEmpty());\n    }\n\nprivate boolean canInsertAmountIntoOutputSlots(ItemStack result, ItemStack result2, ItemStack result3, ItemStack result4) {\n    return this.getStack(OUTPUT_SLOT_1).getCount() + result.getCount() &lt;= getStack(OUTPUT_SLOT_1).getMaxCount() &amp;&amp;\n        this.getStack(OUTPUT_SLOT_2).getCount() + result2.getCount() &lt;= getStack(OUTPUT_SLOT_2).getMaxCount() &amp;&amp;\n        this.getStack(OUTPUT_SLOT_3).getCount() + result3.getCount() &lt;= getStack(OUTPUT_SLOT_3).getMaxCount() &amp;&amp;\n        this.getStack(OUTPUT_SLOT_4).getCount() + result4.getCount() &lt;= getStack(OUTPUT_SLOT_4).getMaxCount();\n}\n</code></pre> As you can see, we have two items in the first method, we check if the same item is in output slot 1 or 2 (or 3 or 4)  or that the output slot is empty. In the second method we compore the amount of items already in the output slots added to the result if thats smaller or equal to the maximum count of 64.</p> <p>Here we check if there is an item that can be inserted into the output slots and if there is a correct amount of it.</p> hasRecipe()<pre><code>private boolean hasRecipe() {\n    Optional&lt;RecipeEntry&lt;ExampleRecipe&gt;&gt; recipe = getCurrentRecipe();\n\n    return recipe.isPresent() &amp;&amp; canInsertAmountIntoOutputSlot(recipe.get().value().getResult(null), recipe.get().value().getSecondResult(null), \n        recipe.get().value().getThirdResult(null), recipe.get().value().getFourthResult(null))\n\n        &amp;&amp; \n        canInsertItemIntoOutputSlot(recipe.get().value().getResult(null).getItem(), recipe.get().value().getSecondResult(null).getItem(), \n            recipe.get().value().getThirdResult(null).getItem(), recipe.get().value().getFourthResult(null).getItem());\n}\n</code></pre> <p>The <code>increaseCraftProgress()</code>, <code>resetProgress()</code> and <code>hasCraftingFinished</code> methods aren't really that special so I'll list them here:</p> <p>resetProgress() &amp; increaseCraftProgress() &amp; hasCraftingFinished()<pre><code>private void resetProgress() {\n    this.progress = 0;\n}\nprivate void increaseCraftProgress() {\n    progress++;\n}\nprivate boolean hasCraftingFinished() {\n    return progress &gt;= maxProgress;\n}\n</code></pre> Before we can make the last method used in the <code>tick()</code> method, we need a helper method called <code>getCurrentRecipe()</code> which gets the current recipe by accessing the recipe manager. getCurrentRecipe()<pre><code>private Optional&lt;RecipeEntry&lt;ExampleRecipe&gt;&gt; getCurrentRecipe() {\n    SimpleInventory inv = new SimpleInventory(this.size());\n    for(int i = 0; i &lt; this.size(); i++) {\n        inv.setStack(i, this.getStack(i));\n    }\n\n    return getWorld().getRecipeManager().getFirstMatch(ExampleRecipe.Type.INSTANCE, inv, getWorld());\n}\n</code></pre> Now we can make the <code>craftItems()</code> method:</p> craftItems()<pre><code>private void craftItem() {\n    Optional&lt;RecipeEntry&lt;ExampleRecipe&gt;&gt; recipe = getCurrentRecipe();\n\n    this.removeStack(INPUT_SLOT, 1);\n\n    this.setStack(OUTPUT_SLOT_1, new ItemStack(recipe.get().value().getResult(null).getItem(),\n        getStack(OUTPUT_SLOT_1).getCount() + recipe.get().value().getResult(null).getCount()));\n    this.setStack(OUTPUT_SLOT_2, new ItemStack(recipe.get().value().getSecondResult(null).getItem(),\n        getStack(OUTPUT_SLOT_2).getCount() + recipe.get().value().getSecondResult(null).getCount()));\n    this.setStack(OUTPUT_SLOT_3), new ItemStack(recipe.get().value().getThirdResult(null).getItem(), \n        getStack(OUTPUT_SLOT_3).getCount() + recipe.get().value().getThirdResult(null).getItem());\n    this.setStack(OUTPUT_SLOT_4), new ItemStack(recipe.get().value().getFourthResult(null).getItem(), \n        getStack(OUTPUT_SLOT_4).getCount() + recipe.get().value().getFourthResult(null).getItem());\n}\n</code></pre> <p>The last thing, for the block entity, we need to do is override two more methods:</p> toUpdatePacket() &amp; toInitialChunkDataNbt()<pre><code>@Nullable\n@Override\npublic Packet&lt;ClientPlayPacketListener&gt; toUpdatePacket() {\n    return BlockEntityUpdateS2CPacket.create(this);\n}\n\n@Override\npublic NbtCompound toInitialChunkDataNbt() {\n    return createNbt();\n}\n</code></pre> <p>The finished class should look something like this:</p> Finished class<pre><code>import io.github.scaredsmods.examplemod.recipe.ExampleRecipe;\nimport io.github.scaredsmods.examplemod.screenhandler.ExampleScreenHandler;\nimport net.fabricmc.fabric.api.screenhandler.v1.ExtendedScreenHandlerFactory;\nimport net.minecraft.block.BlockState;\nimport net.minecraft.block.entity.BlockEntity;\nimport net.minecraft.entity.player.PlayerEntity;\nimport net.minecraft.entity.player.PlayerInventory;\nimport net.minecraft.inventory.Inventories;\nimport net.minecraft.inventory.SimpleInventory;\nimport net.minecraft.item.Item;\nimport net.minecraft.item.ItemStack;\nimport net.minecraft.nbt.NbtCompound;\nimport net.minecraft.network.PacketByteBuf;\nimport net.minecraft.network.listener.ClientPlayPacketListener;\nimport net.minecraft.network.packet.Packet;\nimport net.minecraft.network.packet.s2c.play.BlockEntityUpdateS2CPacket;\nimport net.minecraft.recipe.RecipeEntry;\nimport net.minecraft.screen.PropertyDelegate;\nimport net.minecraft.screen.ScreenHandler;\nimport net.minecraft.server.network.ServerPlayerEntity;\nimport net.minecraft.text.Text;\nimport net.minecraft.util.collection.DefaultedList;\nimport net.minecraft.util.math.BlockPos;\nimport net.minecraft.world.World;\nimport org.jetbrains.annotations.Nullable;\n\nimport java.util.Optional;\n\npublic class ExampleBlockEntity extends BlockEntity implements ExtendedScreenHandlerFactory, ImplementedInventory{\n\n    private final DefaultedList&lt;ItemStack&gt; inventory = DefaultedList.ofSize(5, ItemStack.EMPTY);\n\n    private static final int INPUT_SLOT = 0;\n    private static final int OUTPUT_SLOT_1 = 1;\n    private static final int OUTPUT_SLOT_2 = 2;\n    private static final int OUTPUT_SLOT_3 = 3;\n    private static final int OUTPUT_SLOT_4 = 4;\n\n    protected final PropertyDelegate propertyDelegate;\n    private int progress = 0;\n    private int maxProgress = 100;\n\n    public ExampleBlockEntity(BlockPos pos, BlockState state) {\n        super(ModBlockEntities.EXAMPLE_BLOCK_ENTITY, pos, state);\n        this.propertyDelegate = new PropertyDelegate() {\n            @Override\n            public int get(int index) {\n                return switch (index) {\n                    case 0 -&gt; ExampleBlockEntity.this.progress;\n                    case 1 -&gt; ExampleBlockEntity.this.maxProgress;\n                    default -&gt; 0;\n                };\n            }\n\n            @Override\n            public void set(int index, int value) {\n                switch (index) {\n                    case 0 -&gt; ExampleBlockEntity.this.progress = value;\n                    case 1 -&gt; ExampleBlockEntity.this.maxProgress = value;\n                }\n            }\n\n            @Override\n            public int size() {\n                return 5;\n            }\n        };\n    }\n\n\n    @Override\n    public void writeScreenOpeningData(ServerPlayerEntity player, PacketByteBuf buf) {\n        buf.writeBlockPos(this.pos);\n    }\n\n\n    @Override\n    public Text getDisplayName() {\n        return Text.literal(\"Example\");//(1)!\n    }\n\n    @Override\n    public DefaultedList&lt;ItemStack&gt; getItems() {\n        return inventory;\n    }\n\n    @Override\n    public void writeNbt(NbtCompound nbt) {\n        super.writeNbt(nbt);\n        Inventories.writeNbt(nbt, inventory);\n        nbt.putInt(\"example_block.progress\", progress);\n    }\n\n    @Override\n    public void readNbt(NbtCompound nbt) {\n        super.readNbt(nbt);\n        Inventories.readNbt(nbt, inventory);\n        progress = nbt.getInt(\"example_block.progress\");\n    }\n\n\n    @Nullable\n    @Override\n    public ScreenHandler createMenu(int syncId, PlayerInventory playerInventory, PlayerEntity player) {\n        return new ExampleScreenHandler(syncId, playerInventory, this, this.propertyDelegate);\n    }\n\n    public void tick(World world, BlockPos pos, BlockState state) {\n        if(world.isClient()) {\n            return;\n        }\n\n        if(areOutputsSlotEmptyOrReceivable()) {\n            if(this.hasRecipe()) {\n                this.increaseCraftProgress();\n                markDirty(world, pos, state);\n\n                if(hasCraftingFinished()) {\n                    this.craftItem();\n                    this.resetProgress();\n                }\n            } else {\n                this.resetProgress();\n            }\n        } else {\n            this.resetProgress();\n            markDirty(world, pos, state);\n        }\n    }\n\n    private void resetProgress() {\n        this.progress = 0;\n    }\n\n    private void craftItem() {\n    Optional&lt;RecipeEntry&lt;ExampleRecipe&gt;&gt; recipe = getCurrentRecipe();\n\n        this.removeStack(INPUT_SLOT, 1);\n\n        this.setStack(OUTPUT_SLOT_1, new ItemStack(recipe.get().value().getResult(null).getItem(),\n            getStack(OUTPUT_SLOT_1).getCount() + recipe.get().value().getResult(null).getCount()));\n        this.setStack(OUTPUT_SLOT_2, new ItemStack(recipe.get().value().getSecondResult(null).getItem(),\n            getStack(OUTPUT_SLOT_2).getCount() + recipe.get().value().getSecondResult(null).getCount()));\n        this.setStack(OUTPUT_SLOT_3), new ItemStack(recipe.get().value().getThirdResult(null).getItem(), \n            getStack(OUTPUT_SLOT_3).getCount() + recipe.get().value().getThirdResult(null).getItem());\n        this.setStack(OUTPUT_SLOT_4), new ItemStack(recipe.get().value().getFourthResult(null).getItem(), \n            getStack(OUTPUT_SLOT_4).getCount() + recipe.get().value().getFourthResult(null).getItem());\n    }   \n\n    private boolean hasCraftingFinished() {\n        return progress &gt;= maxProgress;\n    }\n\n    private void increaseCraftProgress() {\n        progress++;\n    }\n\n    private boolean hasRecipe() {\n    Optional&lt;RecipeEntry&lt;ExampleRecipe&gt;&gt; recipe = getCurrentRecipe();\n\n        return recipe.isPresent() &amp;&amp; canInsertAmountIntoOutputSlot(recipe.get().value().getResult(null), recipe.get().value().getSecondResult(null), \n                recipe.get().value().getThirdResult(null), recipe.get().value().getFourthResult(null))\n\n            &amp;&amp; \n            canInsertItemIntoOutputSlot(recipe.get().value().getResult(null).getItem(), recipe.get().value().getSecondResult(null).getItem(), \n                recipe.get().value().getThirdResult(null).getItem(), recipe.get().value().getFourthResult(null).getItem());\n    }\n\n    private Optional&lt;RecipeEntry&lt;ExampleRecipe&gt;&gt; getCurrentRecipe() {\n        SimpleInventory inv = new SimpleInventory(this.size());\n        for(int i = 0; i &lt; this.size(); i++) {\n            inv.setStack(i, this.getStack(i));\n        }\n\n        return getWorld().getRecipeManager().getFirstMatch(ExampleRecipe.Type.INSTANCE, inv, getWorld());\n    }\n\n    private boolean canInsertItemIntoOutputSlots(Item item, Item item2, Item item3, Item item4) {\n    return (this.getStack(OUTPUT_SLOT_1).getItem() == item || this.getStack(OUTPUT_SLOT_1).isEmpty()) &amp;&amp;\n        (this.getStack(OUTPUT_SLOT_2).getItem() == item2 || this.getStack(OUTPUT_SLOT_2).isEmpty()) &amp;&amp;\n        (this.getStack(OUTPUT_SLOT_3).getItem() == item3 || this.getStack(OUTPUT_SLOT_3).isEmpty()) &amp;&amp;\n        (this.getStack(OUTPUT_SLOT_4).getItem() == item4 || this.getStack(OUTPUT_SLOT_4).isEmpty());\n    }\n\n    private boolean canInsertAmountIntoOutputSlots(ItemStack result, ItemStack result2, ItemStack result3, ItemStack result4) {\n        return this.getStack(OUTPUT_SLOT_1).getCount() + result.getCount() &lt;= getStack(OUTPUT_SLOT_1).getMaxCount() &amp;&amp;\n            this.getStack(OUTPUT_SLOT_2).getCount() + result2.getCount() &lt;= getStack(OUTPUT_SLOT_2).getMaxCount() &amp;&amp;\n            this.getStack(OUTPUT_SLOT_3).getCount() + result3.getCount() &lt;= getStack(OUTPUT_SLOT_3).getMaxCount() &amp;&amp;\n            this.getStack(OUTPUT_SLOT_4).getCount() + result4.getCount() &lt;= getStack(OUTPUT_SLOT_4).getMaxCount();\n    }\n\n    private boolean areOutputsSlotEmptyOrReceivable() {\n    return (this.getStack(OUTPUT_SLOT_1).isEmpty() || this.getStack(OUTPUT_SLOT_1).getCount() &lt; this.getStack(OUTPUT_SLOT_1).getMaxCount())\n            &amp;&amp;\n            (this.getStack(OUTPUT_SLOT_2).isEmpty() || this.getStack(OUTPUT_SLOT_2).getCount() &lt; this.getStack(OUTPUT_SLOT_2).getMaxCount())\n            &amp;&amp; \n            (this.getStack(OUTPUT_SLOT_3).isEmpty() || this.getStack(OUTPUT_SLOT_3).getCount() &lt; this.getStack(OUTPUT_SLOT_3).getMaxCount())\n            &amp;&amp;\n            (this.getStack(OUTPUT_SLOT_4).isEmpty() || this.getStack(OUTPUT_SLOT_4).getCount() &lt; this.getStack(OUTPUT_SLOT_4).getMaxCount());\n    }  \n\n    @Nullable\n    @Override\n    public Packet&lt;ClientPlayPacketListener&gt; toUpdatePacket() {\n        return BlockEntityUpdateS2CPacket.create(this);\n    }\n\n    @Override\n    public NbtCompound toInitialChunkDataNbt() {\n        return createNbt();\n    }\n}\n</code></pre> <p>Note that at this point, there will be alot of errors present because we, for example, haven't made the <code>ExampleRecipe</code> class. That is exactly what we are going to do now. Most of the errors in the <code>ExampleBlock</code> class should be gone, the only error that should remain is the error on the <code>onUse()</code> method.</p> <p>Making a custom recipe</p>"},{"location":"mods/more-outputs-api/block-entity/three-outputs/","title":"Block Entity with two output slots","text":"<p>To create a block entity with two output slots, create a new class in <code>net.example.yourmodid.block.entity</code>, the class extends <code>BlockEntity</code> and implements <code>ExtendedScreenHandlerFactory, ImplementedInventory</code></p> <p>In action, it would look like this:</p> <pre><code>public class ExampleBlockEntity extends BlockEntity implements ExtendedScreenHandlerFactory, ImplmentedInventory {\n\n\n}\n</code></pre>"},{"location":"mods/more-outputs-api/block-entity/three-outputs/#fields-constructor","title":"Fields &amp; constructor","text":"<p>Before we can make all the required methods, we need a few fields and a constructor.</p> <pre><code>private final DefaultedList&lt;ItemStack&gt; inventory = DefaultedList.ofSize(4, ItemStack.EMPTY);//(1)!\n\nprivate static final int INPUT_SLOT = 0;//(2)!\nprivate static final int OUTPUT_SLOT_1 = 1;//(3)!\nprivate static final int OUTPUT_SLOT_2 = 2;//(4)!\nprivate static final int OUTPUT_SLOT_3 = 3;//(5)!\n\nprotected final PropertyDelegate propertyDelegate;\nprivate int progress = 0;//(6)!\nprivate int maxProgress = 100; //(7)!\n</code></pre> <ol> <li>IMPORTANT: This should be the total amount of slots in the block entity &amp; recipe. Including the input &amp; output slots</li> <li>This is the slot you put the item to be crafted in.</li> <li>This is the first of the outputs from the recipe</li> <li>This is the second output from the recipe</li> <li>This is the third output from the recipe</li> <li>At this point, the block entity (machine) starts crafting</li> <li>This is the max amount of time the crafting takes</li> </ol> <p>The constructor should look like this:</p> <pre><code>public ExampleBlockEntity(BlockPos pos, BlockState state) {\n    super(ModBlockEntities.EXAMPLE_BLOCK_ENTITY, pos, state);\n    this.propertyDelegate = new PropertyDelegate() {\n        @Override\n        public int get(int index) {\n            return switch (index) {\n                case 0 -&gt; ExampleBlockEntity.this.progress;\n                case 1 -&gt; ExampleBlockEntity.this.maxProgress;\n                default -&gt; 0;\n            };\n        }\n\n        @Override\n        public void set(int index, int value) {\n            switch (index) {\n                case 0 -&gt; ExampleBlockEntity.this.progress = value;\n                case 1 -&gt; ExampleBlockEntity.this.maxProgress = value;\n            }\n        }\n\n        @Override\n        public int size() {\n            return 4; // (1)\n        }\n    };\n}\n</code></pre> <ol> <li>IMPORTANT: This should be the total amount of slots in the block entity &amp; recipe. Including the input &amp; output slots</li> </ol>"},{"location":"mods/more-outputs-api/block-entity/three-outputs/#required-methods","title":"Required methods","text":"<p>Now we can make all the required methods neccessary: </p> writeScreenOpeningData()<pre><code>@Override\npublic void writeScreenOpeningData(ServerPlayerEntity player, PacketByteBuf buf) {\n    buf.writeBlockPos(this.pos);\n}\n</code></pre> getDisplayName()<pre><code>@Override\npublic Text getDisplayName() {\n    return Text.literal(\"Example Block\"); // (1)!\n}\n</code></pre> <ol> <li>I would recommend that you make this translatable by replacing <code>Text.literal()</code> with <code>Text.translatable</code> and adding a translation key and translate it in for example <code>nl_nl.json</code></li> </ol> getItems()<pre><code>@Override\npublic DefaultedList&lt;ItemStack&gt; getItems() {\n    return inventory;\n}\n</code></pre> readNbt() and writeNbt()<pre><code>@Override\npublic void writeNbt(NbtCompound nbt) {\n    super.writeNbt(nbt);\n    Inventories.writeNbt(nbt, inventory);\n    nbt.putInt(\"example_block.progress\", progress); // (1)!\n}\n\n@Override\npublic void readNbt(NbtCompound nbt) {\n    super.readNbt(nbt);\n    Inventories.readNbt(nbt, inventory);\n    progress = nbt.getInt(\"example_block.progress\"); // (2)!\n}\n</code></pre> <ol> <li>These two strings should match!</li> <li>These two strings should match!</li> </ol> createMenu()<pre><code>@Nullable\n@Override\npublic ScreenHandler createMenu(int syncId, PlayerInventory playerInventory, PlayerEntity player) {\n    return new ExampleScreenHandler(syncId, playerInventory, this, this.propertyDelegate);//(1)!\n}\n</code></pre> <ol> <li>\u274c Error: Class not created</li> </ol> tick()<pre><code>public void tick(World world, BlockPos pos, BlockState state) {//(1)!\n    if(world.isClient()) {\n        return;\n    }\n\n\n    if(areOutputSlotsEmptyOreReceivable()) {\n        if(this.hasRecipe()) {\n            this.increaseCraftProgress();\n            markDirty(world, pos, state);\n\n            if(hasCraftingFinished()) {\n                this.craftItem();\n                this.resetProgress();\n            }\n        } else {\n            this.resetProgress();\n        }\n    } else {\n        this.resetProgress();\n        markDirty(world, pos, state);\n    }\n}\n</code></pre> <ol> <li>\u274c Here should be a few errors present, as we haven't made those methods yet</li> </ol> <p>Now we are going to make the methods that are going to have influence on how the <code>tick()</code> method above behaves. Im doing it from top to bottom, and the first method (or boolean) is:</p> <p>areOutputSlotsEmptyOrReceivable()<pre><code>private boolean areOutputsSlotEmptyOrReceivable() {\n    return (this.getStack(OUTPUT_SLOT_1).isEmpty() || this.getStack(OUTPUT_SLOT_1).getCount() &lt; this.getStack(OUTPUT_SLOT_1).getMaxCount())\n            &amp;&amp;\n            (this.getStack(OUTPUT_SLOT_2).isEmpty() || this.getStack(OUTPUT_SLOT_2).getCount() &lt; this.getStack(OUTPUT_SLOT_2).getMaxCount())\n            &amp;&amp; \n            (this.getStack(OUTPUT_SLOT_3).isEmpty() || this.getStack(OUTPUT_SLOT_3).getCount() &lt; this.getStack(OUTPUT_SLOT_3).getMaxCount());\n}\n</code></pre> What we are doing here, is checking if the output slots are empty or in the case that there \u00eds an item in the slot, we check if the amount of items is smaller than 64 (<code>getMaxCount()</code>)</p> <p>Then, we check if the block entity has a recipe with <code>hasRecipe()</code> but before that methods, we need two other helper methods:</p> <p>canInsertItemIntoOutputSlots() &amp; canInsertAmountIntoOutputSlots()<pre><code>private boolean canInsertItemIntoOutputSlots(Item item, Item item2, Item item3) {\n    return (this.getStack(OUTPUT_SLOT_1).getItem() == item || this.getStack(OUTPUT_SLOT_1).isEmpty()) &amp;&amp;\n        (this.getStack(OUTPUT_SLOT_2).getItem() == item2 || this.getStack(OUTPUT_SLOT_2).isEmpty()) &amp;&amp;\n        (this.getStack(OUTPUT_SLOT_3).getItem() == item3 || this.getStack(OUTPUT_SLOT_3).isEmpty());\n    }\n\nprivate boolean canInsertAmountIntoOutputSlots(ItemStack result, ItemStack result2, ItemStack result3) {\n    return this.getStack(OUTPUT_SLOT_1).getCount() + result.getCount() &lt;= getStack(OUTPUT_SLOT_1).getMaxCount() &amp;&amp;\n        this.getStack(OUTPUT_SLOT_2).getCount() + result2.getCount() &lt;= getStack(OUTPUT_SLOT_2).getMaxCount() &amp;&amp;\n        this.getStack(OUTPUT_SLOT_3).getCount() + result3.getCount() &lt;= getStack(OUTPUT_SLOT_3).getMaxCount();\n}\n</code></pre> As you can see, we have two items in the first method, we check if the same item is in output slot 1 or 2 (or 3 or 4)  or that the output slot is empty. In the second method we compore the amount of items already in the output slots added to the result if thats smaller or equal to the maximum count of 64.</p> <p>Here we check if there is an item that can be inserted into the output slots and if there is a correct amount of it.</p> hasRecipe()<pre><code>private boolean hasRecipe() {\n    Optional&lt;RecipeEntry&lt;ExampleRecipe&gt;&gt; recipe = getCurrentRecipe();\n\n    return recipe.isPresent() &amp;&amp; canInsertAmountIntoOutputSlot(recipe.get().value().getResult(null), recipe.get().value().getSecondResult(null), \n        recipe.get().value().getThirdResult(null))\n\n        &amp;&amp; \n        canInsertItemIntoOutputSlot(recipe.get().value().getResult(null).getItem(), recipe.get().value().getSecondResult(null).getItem(), \n            recipe.get().value().getThirdResult(null).getItem());\n}\n</code></pre> <p>The <code>increaseCraftProgress()</code>, <code>resetProgress()</code> and <code>hasCraftingFinished</code> methods aren't really that special so I'll list them here:</p> <p>resetProgress() &amp; increaseCraftProgress() &amp; hasCraftingFinished()<pre><code>private void resetProgress() {\n    this.progress = 0;\n}\nprivate void increaseCraftProgress() {\n    progress++;\n}\nprivate boolean hasCraftingFinished() {\n    return progress &gt;= maxProgress;\n}\n</code></pre> Before we can make the last method used in the <code>tick()</code> method, we need a helper method called <code>getCurrentRecipe()</code> which gets the current recipe by accessing the recipe manager. getCurrentRecipe()<pre><code>private Optional&lt;RecipeEntry&lt;ExampleRecipe&gt;&gt; getCurrentRecipe() {\n    SimpleInventory inv = new SimpleInventory(this.size());\n    for(int i = 0; i &lt; this.size(); i++) {\n        inv.setStack(i, this.getStack(i));\n    }\n\n    return getWorld().getRecipeManager().getFirstMatch(ExampleRecipe.Type.INSTANCE, inv, getWorld());\n}\n</code></pre> Now we can make the <code>craftItems()</code> method:</p> craftItems()<pre><code>private void craftItem() {\n    Optional&lt;RecipeEntry&lt;ExampleRecipe&gt;&gt; recipe = getCurrentRecipe();\n\n    this.removeStack(INPUT_SLOT, 1);\n\n    this.setStack(OUTPUT_SLOT_1, new ItemStack(recipe.get().value().getResult(null).getItem(),\n        getStack(OUTPUT_SLOT_1).getCount() + recipe.get().value().getResult(null).getCount()));\n    this.setStack(OUTPUT_SLOT_2, new ItemStack(recipe.get().value().getSecondResult(null).getItem(),\n        getStack(OUTPUT_SLOT_2).getCount() + recipe.get().value().getSecondResult(null).getCount()));\n    this.setStack(OUTPUT_SLOT_3), new ItemStack(recipe.get().value().getThirdResult(null).getItem(), \n        getStack(OUTPUT_SLOT_3).getCount() + recipe.get().value().getThirdResult(null).getItem());\n}\n</code></pre> <p>The last thing, for the block entity, we need to do is override two more methods:</p> toUpdatePacket() &amp; toInitialChunkDataNbt()<pre><code>@Nullable\n@Override\npublic Packet&lt;ClientPlayPacketListener&gt; toUpdatePacket() {\n    return BlockEntityUpdateS2CPacket.create(this);\n}\n\n@Override\npublic NbtCompound toInitialChunkDataNbt() {\n    return createNbt();\n}\n</code></pre> <p>The finished class should look something like this:</p> Finished class<pre><code>import io.github.scaredsmods.examplemod.recipe.ExampleRecipe;\nimport io.github.scaredsmods.examplemod.screenhandler.ExampleScreenHandler;\nimport net.fabricmc.fabric.api.screenhandler.v1.ExtendedScreenHandlerFactory;\nimport net.minecraft.block.BlockState;\nimport net.minecraft.block.entity.BlockEntity;\nimport net.minecraft.entity.player.PlayerEntity;\nimport net.minecraft.entity.player.PlayerInventory;\nimport net.minecraft.inventory.Inventories;\nimport net.minecraft.inventory.SimpleInventory;\nimport net.minecraft.item.Item;\nimport net.minecraft.item.ItemStack;\nimport net.minecraft.nbt.NbtCompound;\nimport net.minecraft.network.PacketByteBuf;\nimport net.minecraft.network.listener.ClientPlayPacketListener;\nimport net.minecraft.network.packet.Packet;\nimport net.minecraft.network.packet.s2c.play.BlockEntityUpdateS2CPacket;\nimport net.minecraft.recipe.RecipeEntry;\nimport net.minecraft.screen.PropertyDelegate;\nimport net.minecraft.screen.ScreenHandler;\nimport net.minecraft.server.network.ServerPlayerEntity;\nimport net.minecraft.text.Text;\nimport net.minecraft.util.collection.DefaultedList;\nimport net.minecraft.util.math.BlockPos;\nimport net.minecraft.world.World;\nimport org.jetbrains.annotations.Nullable;\n\nimport java.util.Optional;\n\npublic class ExampleBlockEntity extends BlockEntity implements ExtendedScreenHandlerFactory, ImplementedInventory{\n\n    private final DefaultedList&lt;ItemStack&gt; inventory = DefaultedList.ofSize(4, ItemStack.EMPTY);\n\n    private static final int INPUT_SLOT = 0;\n    private static final int OUTPUT_SLOT_1 = 1;\n    private static final int OUTPUT_SLOT_2 = 2;\n    private static final int OUTPUT_SLOT_3 = 3;\n\n    protected final PropertyDelegate propertyDelegate;\n    private int progress = 0;\n    private int maxProgress = 100;\n\n    public ExampleBlockEntity(BlockPos pos, BlockState state) {\n        super(ModBlockEntities.EXAMPLE_BLOCK_ENTITY, pos, state);\n        this.propertyDelegate = new PropertyDelegate() {\n            @Override\n            public int get(int index) {\n                return switch (index) {\n                    case 0 -&gt; ExampleBlockEntity.this.progress;\n                    case 1 -&gt; ExampleBlockEntity.this.maxProgress;\n                    default -&gt; 0;\n                };\n            }\n\n            @Override\n            public void set(int index, int value) {\n                switch (index) {\n                    case 0 -&gt; ExampleBlockEntity.this.progress = value;\n                    case 1 -&gt; ExampleBlockEntity.this.maxProgress = value;\n                }\n            }\n\n            @Override\n            public int size() {\n                return 4;\n            }\n        };\n    }\n\n\n    @Override\n    public void writeScreenOpeningData(ServerPlayerEntity player, PacketByteBuf buf) {\n        buf.writeBlockPos(this.pos);\n    }\n\n\n    @Override\n    public Text getDisplayName() {\n        return Text.literal(\"Example\");//(1)!\n    }\n\n    @Override\n    public DefaultedList&lt;ItemStack&gt; getItems() {\n        return inventory;\n    }\n\n    @Override\n    public void writeNbt(NbtCompound nbt) {\n        super.writeNbt(nbt);\n        Inventories.writeNbt(nbt, inventory);\n        nbt.putInt(\"example_block.progress\", progress);\n    }\n\n    @Override\n    public void readNbt(NbtCompound nbt) {\n        super.readNbt(nbt);\n        Inventories.readNbt(nbt, inventory);\n        progress = nbt.getInt(\"example_block.progress\");\n    }\n\n\n    @Nullable\n    @Override\n    public ScreenHandler createMenu(int syncId, PlayerInventory playerInventory, PlayerEntity player) {\n        return new ExampleScreenHandler(syncId, playerInventory, this, this.propertyDelegate);\n    }\n\n    public void tick(World world, BlockPos pos, BlockState state) {\n        if(world.isClient()) {\n            return;\n        }\n\n        if(areOutputsSlotEmptyOrReceivable()) {\n            if(this.hasRecipe()) {\n                this.increaseCraftProgress();\n                markDirty(world, pos, state);\n\n                if(hasCraftingFinished()) {\n                    this.craftItem();\n                    this.resetProgress();\n                }\n            } else {\n                this.resetProgress();\n            }\n        } else {\n            this.resetProgress();\n            markDirty(world, pos, state);\n        }\n    }\n\n    private void resetProgress() {\n        this.progress = 0;\n    }\n\n    private void craftItem() {\n        Optional&lt;RecipeEntry&lt;ExampleRecipe&gt;&gt; recipe = getCurrentRecipe();\n\n        this.removeStack(INPUT_SLOT, 1);\n\n        this.setStack(OUTPUT_SLOT_1, new ItemStack(recipe.get().value().getResult(null).getItem(),\n                getStack(OUTPUT_SLOT_1).getCount() + recipe.get().value().getResult(null).getCount()));\n        this.setStack(OUTPUT_SLOT_2, new ItemStack(recipe.get().value().getSecondResult(null).getItem(),\n                getStack(OUTPUT_SLOT_2).getCount() + recipe.get().value().getSecondResult(null).getCount()));\n        this.setStack(OUTPUT_SLOT_3, new ItemStack(recipe.get().value().getThirdResult(null).getItem(),\n                getStack(OUTPUT_SLOT_3).getCount() + recipe.get().value().getThirdResult(null).getCount()));\n    }\n\n    private boolean hasCraftingFinished() {\n        return progress &gt;= maxProgress;\n    }\n\n    private void increaseCraftProgress() {\n        progress++;\n    }\n\n    private boolean hasRecipe() {\n        Optional&lt;RecipeEntry&lt;ExampleRecipe&gt;&gt; recipe = getCurrentRecipe();\n\n        return recipe.isPresent() &amp;&amp; canInsertAmountIntoOutputSlot(recipe.get().value().getResult(null), recipe.get().value().getSecondResult(null), \n                    recipe.get().value().getThirdResult(null))\n\n                &amp;&amp; \n                canInsertItemIntoOutputSlot(recipe.get().value().getResult(null).getItem(), recipe.get().value().getSecondResult(null).getItem(), \n                    recipe.get().value().getThirdResult(null));\n    }\n\n    private Optional&lt;RecipeEntry&lt;ExampleRecipe&gt;&gt; getCurrentRecipe() {\n        SimpleInventory inv = new SimpleInventory(this.size());\n        for(int i = 0; i &lt; this.size(); i++) {\n            inv.setStack(i, this.getStack(i));\n        }\n\n        return getWorld().getRecipeManager().getFirstMatch(ExampleRecipe.Type.INSTANCE, inv, getWorld());\n    }\n\n    private boolean canInsertItemIntoOutputSlots(Item item, Item item2, Item item3) {\n    return (this.getStack(OUTPUT_SLOT_1).getItem() == item || this.getStack(OUTPUT_SLOT_1).isEmpty()) &amp;&amp;\n        (this.getStack(OUTPUT_SLOT_2).getItem() == item2 || this.getStack(OUTPUT_SLOT_2).isEmpty()) &amp;&amp;\n        (this.getStack(OUTPUT_SLOT_3).getItem() == item3 || this.getStack(OUTPUT_SLOT_3).isEmpty());\n    }\n\n    private boolean canInsertAmountIntoOutputSlots(ItemStack result, ItemStack result2, ItemStack result3) {\n        return this.getStack(OUTPUT_SLOT_1).getCount() + result.getCount() &lt;= getStack(OUTPUT_SLOT_1).getMaxCount() &amp;&amp;\n            this.getStack(OUTPUT_SLOT_2).getCount() + result2.getCount() &lt;= getStack(OUTPUT_SLOT_2).getMaxCount() &amp;&amp;\n            this.getStack(OUTPUT_SLOT_3).getCount() + result3.getCount() &lt;= getStack(OUTPUT_SLOT_3).getMaxCount();\n    }\n\n    private boolean areOutputsSlotEmptyOrReceivable() {\n    return (this.getStack(OUTPUT_SLOT_1).isEmpty() || this.getStack(OUTPUT_SLOT_1).getCount() &lt; this.getStack(OUTPUT_SLOT_1).getMaxCount())\n            &amp;&amp;\n            (this.getStack(OUTPUT_SLOT_2).isEmpty() || this.getStack(OUTPUT_SLOT_2).getCount() &lt; this.getStack(OUTPUT_SLOT_2).getMaxCount())\n            &amp;&amp; \n            (this.getStack(OUTPUT_SLOT_3).isEmpty() || this.getStack(OUTPUT_SLOT_3).getCount() &lt; this.getStack(OUTPUT_SLOT_3).getMaxCount());\n    }   \n\n    @Nullable\n    @Override\n    public Packet&lt;ClientPlayPacketListener&gt; toUpdatePacket() {\n        return BlockEntityUpdateS2CPacket.create(this);\n    }\n\n    @Override\n    public NbtCompound toInitialChunkDataNbt() {\n        return createNbt();\n    }\n}\n</code></pre> <p>Note that at this point, there will be alot of errors present because we, for example, haven't made the <code>ExampleRecipe</code> class. That is exactly what we are going to do now. Most of the errors in the <code>ExampleBlock</code> class should be gone, the only error that should remain is the error on the <code>onUse()</code> method.</p> <p>Making a custom recipe</p>"},{"location":"mods/more-outputs-api/block-entity/two-outputs/","title":"Block Entity with two output slots","text":"<p>To create a block entity with two output slots, create a new class in <code>net.example.yourmodid.block.entity</code>, the class extends <code>BlockEntity</code> and implements <code>ExtendedScreenHandlerFactory, ImplementedInventory</code></p> <p>In action, it would look like this:</p> <pre><code>public class ExampleBlockEntity extends BlockEntity implements ExtendedScreenHandlerFactory, ImplmentedInventory {\n\n\n}\n</code></pre>"},{"location":"mods/more-outputs-api/block-entity/two-outputs/#fields-constructor","title":"Fields &amp; constructor","text":"<p>Before we can make all the required methods, we need a few fields and a constructor.</p> <pre><code>private final DefaultedList&lt;ItemStack&gt; inventory = DefaultedList.ofSize(3, ItemStack.EMPTY); // (1)!\n\nprivate static final int INPUT_SLOT = 0; // (2)!\nprivate static final int OUTPUT_SLOT_1 = 1; // (3)!\nprivate static final int OUTPUT_SLOT_2 = 2; // (4)!\n\nprotected final PropertyDelegate propertyDelegate;\nprivate int progress = 0; // (5)!\nprivate int maxProgress = 100; // (6)!\n</code></pre> <ol> <li>IMPORTANT: This should be the total amount of slots in the block entity &amp; recipe. Including the input &amp; output slots</li> <li>This is the slot you put the item to be crafted in.</li> <li>This is the first of the outputs from the recipe</li> <li>This is the seconds output from the recipe</li> <li>At this point, the block entity (machine) starts crafting</li> <li>This is the max the crafting takes</li> </ol> <p>The constructor should look like this:</p> <pre><code>public ExampleBlockEntity(BlockPos pos, BlockState state) {\n    super(ModBlockEntities.EXAMPLE_BLOCK_ENTITY, pos, state);\n    this.propertyDelegate = new PropertyDelegate() {\n        @Override\n        public int get(int index) {\n            return switch (index) {\n                case 0 -&gt; ExampleBlockEntity.this.progress;\n                case 1 -&gt; ExampleBlockEntity.this.maxProgress;\n                default -&gt; 0;\n            };\n        }\n\n        @Override\n        public void set(int index, int value) {\n            switch (index) {\n                case 0 -&gt; ExampleBlockEntity.this.progress = value;\n                case 1 -&gt; ExampleBlockEntity.this.maxProgress = value;\n            }\n        }\n\n        @Override\n        public int size() {\n            return 3; // (1)\n        }\n    };\n}\n</code></pre> <ol> <li>IMPORTANT: This should be the total amount of slots in the block entity &amp; recipe. Including the input &amp; output slots</li> </ol>"},{"location":"mods/more-outputs-api/block-entity/two-outputs/#required-methods","title":"Required methods","text":"<p>Now we can make all the required methods neccessary: </p> writeScreenOpeningData()<pre><code>@Override\npublic void writeScreenOpeningData(ServerPlayerEntity player, PacketByteBuf buf) {\n    buf.writeBlockPos(this.pos);\n}\n</code></pre> getDisplayName()<pre><code>@Override\npublic Text getDisplayName() {\n    return Text.literal(\"Example Block\"); // (1)!\n}\n</code></pre> <ol> <li>I would recommend that you make this translatable by replacing <code>Text.literal()</code> with <code>Text.translatable</code></li> </ol> getItems()<pre><code>@Override\npublic DefaultedList&lt;ItemStack&gt; getItems() {\n    return inventory;\n}\n</code></pre> readNbt() and writeNbt()<pre><code>@Override\npublic void writeNbt(NbtCompound nbt) {\n    super.writeNbt(nbt);\n    Inventories.writeNbt(nbt, inventory);\n    nbt.putInt(\"example_block.progress\", progress); // (1)!\n}\n\n@Override\npublic void readNbt(NbtCompound nbt) {\n    super.readNbt(nbt);\n    Inventories.readNbt(nbt, inventory);\n    progress = nbt.getInt(\"example_block.progress\"); // (2)!\n}\n</code></pre> <ol> <li>These two strings should match!</li> <li>These two strings should match!</li> </ol> createMenu()<pre><code>@Nullable\n@Override\npublic ScreenHandler createMenu(int syncId, PlayerInventory playerInventory, PlayerEntity player) {\n    return new ExampleScreenHandler(syncId, playerInventory, this, this.propertyDelegate); // (1)!\n}\n</code></pre> <ol> <li>\u274c Error: Class not created</li> </ol> tick()<pre><code>public void tick(World world, BlockPos pos, BlockState state) { // (1)!\n    if(world.isClient()) {\n        return;\n    }\n\n\n    if(areOutputSlotsEmptyOreReceivable()) {\n        if(this.hasRecipe()) {\n            this.increaseCraftProgress();\n            markDirty(world, pos, state);\n\n            if(hasCraftingFinished()) {\n                this.craftItem();\n                this.resetProgress();\n            }\n        } else {\n            this.resetProgress();\n        }\n    } else {\n        this.resetProgress();\n        markDirty(world, pos, state);\n    }\n}\n</code></pre> <ol> <li>\u274c Here should be a few errors present, as we haven't made those methods yet</li> </ol> <p>Now we are going to make the methods that are going to have influence on how the <code>tick()</code> method above behaves. Im doing it from top to bottom, and the first method (or boolean) is:</p> <p>areOutputSlotsEmptyOrReceivable()<pre><code>private boolean areOutputsSlotEmptyOrReceivable() {\n    return this.getStack(OUTPUT_SLOT_1).isEmpty() || this.getStack(OUTPUT_SLOT_1).getCount() &lt; this.getStack(OUTPUT_SLOT_1).getMaxCount()\n            ||\n            this.getStack(OUTPUT_SLOT_2).isEmpty() || this.getStack(OUTPUT_SLOT_2).getCount() &lt; this.getStack(OUTPUT_SLOT_2).getMaxCount();\n}\n</code></pre> What we are doing here, is checking if the output slots are empty or in the case that there \u00eds an item in the slot, we check if the amount of items is smaller than 64 (<code>getMaxCount()</code>)</p> <p>Then, we check if the block entity has a recipe with <code>hasRecipe()</code> but before that methods, we need two other helper methods:</p> <p>canInsertItemIntoOutputSlots() &amp; canInsertAmountIntoOutputSlots()<pre><code>private boolean canInsertItemIntoOutputSlots(Item item, Item item2) {\n    return this.getStack(OUTPUT_SLOT_1).getItem() == item || this.getStack(OUTPUT_SLOT_1).isEmpty() &amp;&amp;\n        this.getStack(OUTPUT_SLOT_2).getItem() == item2 || this.getStack(OUTPUT_SLOT_2).isEmpty();\n    }\n\nprivate boolean canInsertAmountIntoOutputSlots(ItemStack result, ItemStack result2) {\n    return this.getStack(OUTPUT_SLOT_1).getCount() + result.getCount() &lt;= getStack(OUTPUT_SLOT_1).getMaxCount() &amp;&amp;\n        this.getStack(OUTPUT_SLOT_2).getCount() + result2.getCount() &lt;= getStack(OUTPUT_SLOT_2).getMaxCount();\n}\n</code></pre> As you can see, we have two items in the first method, we check if the same item is in output slot 1 or 2 (or 3 or 4)  or that the output slot is empty. In the second method we compore the amount of items already in the output slots added to the result if thats smaller or equal to the maximum count of 64.</p> <p>Here we check if there is an item that can be inserted into the output slots and if there is a correct amount of it.</p> hasRecipe()<pre><code>private boolean hasRecipe() {\n    Optional&lt;RecipeEntry&lt;ExampleRecipe&gt;&gt; recipe = getCurrentRecipe();\n\n    return recipe.isPresent() &amp;&amp; canInsertAmountIntoOutputSlot(recipe.get().value().getResult(null), recipe.get().value().getSecondResult(null))\n            &amp;&amp; canInsertItemIntoOutputSlot(recipe.get().value().getResult(null).getItem(), recipe.get().value().getSecondResult(null).getItem());\n}\n</code></pre> <p>The <code>increaseCraftProgress()</code>, <code>resetProgress()</code> and <code>hasCraftingFinished</code> methods aren't really that special so I'll list them here:</p> <p>resetProgress() &amp; increaseCraftProgress() &amp; hasCraftingFinished()<pre><code>private void resetProgress() {\n    this.progress = 0;\n}\nprivate void increaseCraftProgress() {\n    progress++;\n}\nprivate boolean hasCraftingFinished() {\n    return progress &gt;= maxProgress;\n}\n</code></pre> Before we can make the last method used in the <code>tick()</code> method, we need a helper method called <code>getCurrentRecipe()</code> which gets the current recipe by accessing the recipe manager. getCurrentRecipe()<pre><code>private Optional&lt;RecipeEntry&lt;ExampleRecipe&gt;&gt; getCurrentRecipe() {\n    SimpleInventory inv = new SimpleInventory(this.size());\n    for(int i = 0; i &lt; this.size(); i++) {\n        inv.setStack(i, this.getStack(i));\n    }\n\n    return getWorld().getRecipeManager().getFirstMatch(ExampleRecipe.Type.INSTANCE, inv, getWorld());\n}\n</code></pre> Now we can make the <code>craftItems()</code> method:</p> craftItems()<pre><code>private void craftItem() {\n    Optional&lt;RecipeEntry&lt;ExampleRecipe&gt;&gt; recipe = getCurrentRecipe();\n\n    this.removeStack(INPUT_SLOT, 1);\n\n    this.setStack(OUTPUT_SLOT_1, new ItemStack(recipe.get().value().getResult(null).getItem(),\n        getStack(OUTPUT_SLOT_1).getCount() + recipe.get().value().getResult(null).getCount()));\n    this.setStack(OUTPUT_SLOT_2, new ItemStack(recipe.get().value().getSecondResult(null).getItem(),\n        getStack(OUTPUT_SLOT_2).getCount() + recipe.get().value().getSecondResult(null).getCount()));\n}\n</code></pre> <p>The last thing, for the block entity, we need to do is override two more methods:</p> toUpdatePacket() &amp; toInitialChunkDataNbt()<pre><code>@Nullable\n@Override\npublic Packet&lt;ClientPlayPacketListener&gt; toUpdatePacket() {\n    return BlockEntityUpdateS2CPacket.create(this);\n}\n\n@Override\npublic NbtCompound toInitialChunkDataNbt() {\n    return createNbt();\n}\n</code></pre> <p>The finished class should look something like this:</p> Finished class<pre><code>import io.github.scaredsmods.examplemod.recipe.ExampleRecipe;\nimport io.github.scaredsmods.examplemod.screenhandler.ExampleScreenHandler;\nimport net.fabricmc.fabric.api.screenhandler.v1.ExtendedScreenHandlerFactory;\nimport net.minecraft.block.BlockState;\nimport net.minecraft.block.entity.BlockEntity;\nimport net.minecraft.entity.player.PlayerEntity;\nimport net.minecraft.entity.player.PlayerInventory;\nimport net.minecraft.inventory.Inventories;\nimport net.minecraft.inventory.SimpleInventory;\nimport net.minecraft.item.Item;\nimport net.minecraft.item.ItemStack;\nimport net.minecraft.nbt.NbtCompound;\nimport net.minecraft.network.PacketByteBuf;\nimport net.minecraft.network.listener.ClientPlayPacketListener;\nimport net.minecraft.network.packet.Packet;\nimport net.minecraft.network.packet.s2c.play.BlockEntityUpdateS2CPacket;\nimport net.minecraft.recipe.RecipeEntry;\nimport net.minecraft.screen.PropertyDelegate;\nimport net.minecraft.screen.ScreenHandler;\nimport net.minecraft.server.network.ServerPlayerEntity;\nimport net.minecraft.text.Text;\nimport net.minecraft.util.collection.DefaultedList;\nimport net.minecraft.util.math.BlockPos;\nimport net.minecraft.world.World;\nimport org.jetbrains.annotations.Nullable;\n\nimport java.util.Optional;\n\npublic class ExampleBlockEntity extends BlockEntity implements ExtendedScreenHandlerFactory, ImplementedInventory{\n\n    private final DefaultedList&lt;ItemStack&gt; inventory = DefaultedList.ofSize(3, ItemStack.EMPTY);\n\n    private static final int INPUT_SLOT = 0;\n    private static final int OUTPUT_SLOT_1 = 1;\n    private static final int OUTPUT_SLOT_2 = 2;\n\n    protected final PropertyDelegate propertyDelegate;\n    private int progress = 0;\n    private int maxProgress = 100;\n\n    public ExampleBlockEntity(BlockPos pos, BlockState state) {\n        super(ModBlockEntities.EXAMPLE_BLOCK_ENTITY, pos, state);\n        this.propertyDelegate = new PropertyDelegate() {\n            @Override\n            public int get(int index) {\n                return switch (index) {\n                    case 0 -&gt; ExampleBlockEntity.this.progress;\n                    case 1 -&gt; ExampleBlockEntity.this.maxProgress;\n                    default -&gt; 0;\n                };\n            }\n\n            @Override\n            public void set(int index, int value) {\n                switch (index) {\n                    case 0 -&gt; ExampleBlockEntity.this.progress = value;\n                    case 1 -&gt; ExampleBlockEntity.this.maxProgress = value;\n                }\n            }\n\n            @Override\n            public int size() {\n                return 3;\n            }\n        };\n    }\n\n\n    @Override\n    public void writeScreenOpeningData(ServerPlayerEntity player, PacketByteBuf buf) {\n        buf.writeBlockPos(this.pos);\n    }\n\n\n    @Override\n    public Text getDisplayName() {\n        return Text.literal(\"Example Block\");\n    }\n\n    @Override\n    public DefaultedList&lt;ItemStack&gt; getItems() {\n        return inventory;\n    }\n\n    @Override\n    public void writeNbt(NbtCompound nbt) {\n        super.writeNbt(nbt);\n        Inventories.writeNbt(nbt, inventory);\n        nbt.putInt(\"example_block.progress\", progress);\n    }\n\n    @Override\n    public void readNbt(NbtCompound nbt) {\n        super.readNbt(nbt);\n        Inventories.readNbt(nbt, inventory);\n        progress = nbt.getInt(\"example_block.progress\");\n    }\n\n\n    @Nullable\n    @Override\n    public ScreenHandler createMenu(int syncId, PlayerInventory playerInventory, PlayerEntity player) {\n        return new ExampleScreenHandler(syncId, playerInventory, this, this.propertyDelegate);\n    }\n\n    public void tick(World world, BlockPos pos, BlockState state) {\n        if(world.isClient()) {\n            return;\n        }\n\n        if(areOutputsSlotEmptyOrReceivable()) {\n            if(this.hasRecipe()) {\n                this.increaseCraftProgress();\n                markDirty(world, pos, state);\n\n                if(hasCraftingFinished()) {\n                    this.craftItem();\n                    this.resetProgress();\n                }\n            } else {\n                this.resetProgress();\n            }\n        } else {\n            this.resetProgress();\n            markDirty(world, pos, state);\n        }\n    }\n\n    private void resetProgress() {\n        this.progress = 0;\n    }\n\n    private void craftItem() {\n        Optional&lt;RecipeEntry&lt;ExampleRecipe&gt;&gt; recipe = getCurrentRecipe();\n\n        this.removeStack(INPUT_SLOT, 1);\n\n        this.setStack(OUTPUT_SLOT_1, new ItemStack(recipe.get().value().getResult(null).getItem(),\n                getStack(OUTPUT_SLOT_1).getCount() + recipe.get().value().getResult(null).getCount()));\n        this.setStack(OUTPUT_SLOT_2, new ItemStack(recipe.get().value().getSecondResult(null).getItem(),\n                getStack(OUTPUT_SLOT_2).getCount() + recipe.get().value().getSecondResult(null).getCount()));\n    }\n\n    private boolean hasCraftingFinished() {\n        return progress &gt;= maxProgress;\n    }\n\n    private void increaseCraftProgress() {\n        progress++;\n    }\n\n    private boolean hasRecipe() {\n        Optional&lt;RecipeEntry&lt;ExampleRecipe&gt;&gt; recipe = getCurrentRecipe();\n\n        return recipe.isPresent() &amp;&amp; canInsertAmountIntoOutputSlot(recipe.get().value().getResult(null), recipe.get().value().getSecondResult(null))\n                &amp;&amp; canInsertItemIntoOutputSlot(recipe.get().value().getResult(null).getItem(), recipe.get().value().getSecondResult(null).getItem());\n    }\n\n    private Optional&lt;RecipeEntry&lt;ExampleRecipe&gt;&gt; getCurrentRecipe() {\n        SimpleInventory inv = new SimpleInventory(this.size());\n        for(int i = 0; i &lt; this.size(); i++) {\n            inv.setStack(i, this.getStack(i));\n        }\n\n        return getWorld().getRecipeManager().getFirstMatch(ExampleRecipe.Type.INSTANCE, inv, getWorld());\n    }\n\n    private boolean canInsertItemIntoOutputSlot(Item item, Item item2) {\n        return this.getStack(OUTPUT_SLOT_1).getItem() == item || this.getStack(OUTPUT_SLOT_1).isEmpty() &amp;&amp;\n                this.getStack(OUTPUT_SLOT_2).getItem() == item2 || this.getStack(OUTPUT_SLOT_2).isEmpty();\n    }\n\n    private boolean canInsertAmountIntoOutputSlot(ItemStack result, ItemStack result2) {\n        return this.getStack(OUTPUT_SLOT_1).getCount() + result.getCount() &lt;= getStack(OUTPUT_SLOT_1).getMaxCount() &amp;&amp;\n                this.getStack(OUTPUT_SLOT_2).getCount() + result2.getCount() &lt;= getStack(OUTPUT_SLOT_2).getMaxCount();\n    }\n\n    private boolean areOutputsSlotEmptyOrReceivable() {\n        return this.getStack(OUTPUT_SLOT_1).isEmpty() || this.getStack(OUTPUT_SLOT_1).getCount() &lt; this.getStack(OUTPUT_SLOT_1).getMaxCount()\n                ||\n                this.getStack(OUTPUT_SLOT_2).isEmpty() || this.getStack(OUTPUT_SLOT_2).getCount() &lt; this.getStack(OUTPUT_SLOT_2).getMaxCount();\n    }\n    @Nullable\n    @Override\n    public Packet&lt;ClientPlayPacketListener&gt; toUpdatePacket() {\n        return BlockEntityUpdateS2CPacket.create(this);\n    }\n\n    @Override\n    public NbtCompound toInitialChunkDataNbt() {\n        return createNbt();\n    }\n}\n</code></pre> <p>Note that at this point, there will be alot of errors present because we, for example, haven't made the <code>ExampleRecipe</code> class. That is exactly what we are going to do now. Most of the errors in the <code>ExampleBlock</code> class should be gone, the only error that should remain is the error on the <code>onUse()</code> method.</p> <p>Making a custom recipe</p>"},{"location":"mods/more-outputs-api/recipe/","title":"Making a custom recipe","text":"<p>To make a recipe that works with multiple outputs, you need a class implementing Recipe, OutputRecipe. Inventory can be replaced with any class that extends inventory. Important is that the class between brackets matches between both classes <p>It would look something like this:</p> <pre><code>public class ExampleRecipe implements Recipe&lt;SimpleInventory&gt;, Output4Recipe&lt;SimpleInventory&gt; {\n\n    // [Methods]\n}\n</code></pre> <p>For every amount of output slots, it works a little bit different, documentation for those can be found below:</p> <ul> <li>2 Outputs</li> <li>3 Outputs</li> <li>4 Outputs</li> </ul>"},{"location":"mods/more-outputs-api/recipe/four-output-recipe/","title":"Making a recipe with four outputs","text":"<p>Like already said, we need a class that implements Recipe, Output3Recipe so lets get started. We also need a RecipeType and RecipeSerializer and we need a ModRecipes class."},{"location":"mods/more-outputs-api/recipe/four-output-recipe/#base-recipe-class","title":"Base recipe class","text":"<p>Start by making a new package in your main package called <code>recipe</code>, then create a new class <code>ExampleRecipe</code> and for the type of inventory I will go for is <code>SimpleInventory</code>. </p> <p>ExampleRecipe<pre><code>public class ExampleRecipe implements Recipe&lt;SimpleInventory&gt;, Output4Recipe&lt;SimpleInventory&gt; {\n}\n</code></pre> Now implement the methods your IDE (Prefferably Intellij IDEA) asks for, don't create the constructor matching super yet. </p> <p>We need a few fields that will depict how the class works, namely a List for the inputs and 2 ItemStacks for the two outputs we have. Fields<pre><code>private final ItemStack output_1;\nprivate final ItemStack output_2;\nprivate final ItemStack output_3;\nprivate final ItemStack output_4;\n\nprivate final List&lt;Ingredient&gt; recipeItems;\n</code></pre> <p>Now you can hover over the class name, and create the constructor matching super. It should look something like this:</p> <p>Implemented methods<pre><code>public class ExampleRecipe implements Recipe&lt;SimpleInventory&gt;, Output2Recipe&lt;SimpleInventory&gt; {\n\n\n    private final ItemStack output_1;\n    private final ItemStack output_2;\n    private final ItemStack output_3;\n    private final ItemStack output_4;\n\n    private final List&lt;Ingredient&gt; recipeItems;\n\n    public ExampleRecipe(List&lt;Ingredient&gt; ingredients, ItemStack itemStack, ItemStack output2, ItemStack output3, ItemStack output4) {\n        this.output_1 = itemStack;\n        this.recipeItems = ingredients;\n        this.output_2 = output2;\n        this.output_3 = output3;\n        this.output_4 = output4;\n    }\n\n    @Override\n    public ItemStack getSecondResult(DynamicRegistryManager registryManager) {\n        return null;\n    }\n\n    @Override\n    public ItemStack craftSecond(SimpleInventory inventory, DynamicRegistryManager registryManager) {\n        return null;\n    }\n\n\n    @Override\n    public ItemStack getThirdResult(DynamicRegistryManager registryManager) {\n        return null;\n    }\n\n    @Override\n    public ItemStack craftThird(SimpleInventory inventory, DynamicRegistryManager registryManager) {\n        return null;\n    }\n\n    @Override\n    public ItemStack getFourthResult(DynamicRegistryManager registryManager) {\n        return null;\n    }\n\n    @Override\n    public ItemStack craftFourth(SimpleInventory inventory, DynamicRegistryManager registryManager) {\n        return null;\n    }\n\n    @Override\n    public boolean matches(SimpleInventory inventory, World world) {\n        return false;\n    }\n\n    @Override\n    public ItemStack craft(SimpleInventory inventory, DynamicRegistryManager registryManager) {\n        return null;\n    }\n\n    @Override\n    public boolean fits(int width, int height) {\n        return false;\n    }\n\n    @Override\n    public ItemStack getResult(DynamicRegistryManager registryManager) {\n        return null;\n    }\n\n    @Override\n    public RecipeSerializer&lt;?&gt; getSerializer() {\n        return null;\n    }\n\n    @Override\n    public RecipeType&lt;?&gt; getType() {\n        return null;\n    }\n}\n</code></pre> Now in the <code>getSecondResult() &amp; craftSecond()</code> methods, return <code>output_2</code>, and <code>getResult() &amp; craft()</code> return <code>output_1</code> <code>getThirdResult() &amp; craftThird()</code> should return <code>output_3</code> The <code>matches()</code> method should look like this:</p> matches()<pre><code>@Override\npublic boolean matches(SimpleInventory inventory, World world) {\n    if(world.isClient()) {\n        return false;\n    }\n\n    return recipeItems.get(0).test(inventory.getStack(0)); //(1)!\n}\n</code></pre> <ol> <li>get(0) can also be replaced with getFirst()</li> </ol> <p>The <code>fits()</code> method should return <code>true</code> Since can't fill in the <code>getSerializer()</code> &amp; <code>getType()</code> methods just yet, remove <code>null;</code> from the return statements to make a deliberate error to help us remember that we need to fill in that method.</p>"},{"location":"mods/more-outputs-api/recipe/four-output-recipe/#recipetype-serializer","title":"RecipeType &amp; Serializer","text":""},{"location":"mods/more-outputs-api/recipe/four-output-recipe/#recipetype","title":"RecipeType","text":"<p>Now we can make the recipe type and recipe serializer, make a new sub class called <code>Type</code> and let it implement <code>RecipeType&lt;ExampleRecipe&gt;</code>. This is a small subclass that only contains two fields: <code>INSTANCE</code> which creates a new instance of the <code>Type</code> class and <code>ID</code> which is the RecipeType ID(entifier)</p> <p>RecipeType<pre><code>public class Type implements RecipeType&lt;ExampleRecipe&gt; {\n\n    public static final Type INSTANCE = new Type();\n    public static final String ID = \"example_recipe\";\n}\n</code></pre> example_recipe can be whatever you want, just make sure its recognizeable.</p>"},{"location":"mods/more-outputs-api/recipe/four-output-recipe/#recipe-serializer","title":"Recipe Serializer","text":"<p>The recipe serializer is a little more complicated but still pretty easy to do. Create another sub class in your class implementing Recipe, ill name it <code>Serializer</code>. <code>Serializer</code> also needs the <code>INSTANCE</code> &amp; <code>ID</code> fields but <code>INSTANCE</code> is equal to <code>new Serializer()</code>.</p> <p>This is what the class should look like: </p> Serializer<pre><code>public static class Serializer implements RecipeSerializer&lt;ExampleRecipe&gt; {\n\n    public static final Serializer INSTANCE = new Serializer();\n    public static final String ID = \"example_recipe\"\n    /*\n    This method is neccessary because of the codec, this is how it works\n    If you have more outputs, duplicate the third or fourth line and adjust it to your needs\n    */  \n    public static final Codec&lt;ExampleRecipe&gt; CODEC = RecordCodecBuilder.create(in -&gt; in.group(\n            validateAmount(Ingredient.DISALLOW_EMPTY_CODEC, 9).fieldOf(\"ingredients\").forGetter(ExampleRecipe::getIngredients),\n            ItemStack.RECIPE_RESULT_CODEC.fieldOf(\"output_1\").forGetter(r -&gt; r.output_1),\n            ItemStack.RECIPE_RESULT_CODEC.fieldOf(\"output_2\").forGetter(r -&gt; r.output_2),\n            ItemStack.RECIPE_RESULT_CODEC.fieldOf(\"output_3\").forGetter(r -&gt; r.output_3),\n            ItemStack.RECIPE_RESULT_CODEC.fieldOf(\"output_4\").forGetter(r -&gt; r.output_4)\n        ).apply(in, ExampleRecipe::new));\n\n\n\n\n    private static Codec&lt;List&lt;Ingredient&gt;&gt; validateAmount(Codec&lt;Ingredient&gt; delegate, int max) {\n        return Codecs.validate(Codecs.validate(\n                delegate.listOf(), list -&gt; list.size() &gt; max ? DataResult.error(() -&gt; \"Recipe has too many ingredients!\") : DataResult.success(list)\n        ), list -&gt; list.isEmpty() ? DataResult.error(() -&gt; \"Recipe has no ingredients!\") : DataResult.success(list));\n    }\n\n    @Override\n    public Codec&lt;ExampleRecipe&gt; codec() {\n        return CODEC;\n    }\n\n    @Override\n    public ExampleRecipe read(PacketByteBuf buf) {\n        DefaultedList&lt;Ingredient&gt; inputs = DefaultedList.ofSize(buf.readInt(), Ingredient.EMPTY);\n\n        for(int i = 0; i &lt; inputs.size(); i++) {\n            inputs.set(i, Ingredient.fromPacket(buf));\n        }\n\n        ItemStack output_1 = buf.readItemStack();\n        ItemStack output_2 = buf.readItemStack();\n        ItemStack output_3 = buf.readItemStack();\n        ItemStack output_4 = buf.readItemStack();\n        return new ExampleRecipe(inputs, output_1, output_2, output_3, output_4);//(1)!\n    }\n\n    @Override\n    public void write(PacketByteBuf buf, ExampleRecipe recipe) {\n        buf.writeInt(recipe.getIngredients().size());\n\n        for (Ingredient ingredient : recipe.getIngredients()) {\n                ingredient.write(buf);\n        }\n\n        buf.writeItemStack(recipe.getResult(null));\n        buf.writeItemStack(recipe.getSecondResult(null));\n        buf.writeItemStack(recipe.getThirdResult(null));\n        buf.writeItemStack(recipe.getFourthResult(null));\n    }\n}\n</code></pre> <ol> <li>If you have more outputs, declare more ItemStack's like above and add them to the constructor the same way as in the beginning.</li> </ol> <p>Now we can fill in <code>getSerializer()</code> &amp; <code>getType()</code> :</p> <pre><code>@Override\npublic RecipeSerializer&lt;?&gt; getSerializer() {\n    return Serializer.INSTANCE;\n}\n\n@Override\npublic RecipeType&lt;?&gt; getType() {\n    return Type.INSTANCE;\n}\n</code></pre>"},{"location":"mods/more-outputs-api/recipe/four-output-recipe/#registering","title":"Registering","text":"<p>To register the recipes, make a new class in the <code>recipe</code> package, I will call that <code>ModRecipes</code></p> <p>Make a method called <code>registerModRecipes()</code>, it should be a void, in the method add these lines to the method:</p> LinesFull method Registering RecipeType &amp; Serializer<pre><code>    Registry.register(Registries.RECIPE_SERIALIZER, new Identifier(ExampleMod.MOD_ID, ExampleRecipe.Serializer.ID),\n        ExampleRecipe.Serializer.INSTANCE);\n    Registry.register(Registries.RECIPE_TYPE, new Identifier(ExampleMod.MOD_ID, ExampleRecipe.Type.ID),\n        ExampleRecipe.Type.INSTANCE);\n</code></pre> Full method<pre><code>public static void registerRecipes() {\n    Registry.register(Registries.RECIPE_SERIALIZER, new Identifier(ExampleMod.MOD_ID, ExampleRecipe.Serializer.ID),\n            ExampleRecipe.Serializer.INSTANCE);\n    Registry.register(Registries.RECIPE_TYPE, new Identifier(ExampleMod.MOD_ID, ExampleRecipe.Type.ID),\n            ExampleRecipe.Type.INSTANCE);\n}\n</code></pre>"},{"location":"mods/more-outputs-api/recipe/three-output-recipe/","title":"Making a recipe with three outputs","text":"<p>Like already said, we need a class that implements Recipe, Output3Recipe so lets get started. We also need a RecipeType and RecipeSerializer and we need a ModRecipes class."},{"location":"mods/more-outputs-api/recipe/three-output-recipe/#base-recipe-class","title":"Base recipe class","text":"<p>Start by making a new package in your main package called <code>recipe</code>, then create a new class <code>ExampleRecipe</code> and for the type of inventory I will go for is <code>SimpleInventory</code>. </p> <p>ExampleRecipe<pre><code>public class ExampleRecipe implements Recipe&lt;SimpleInventory&gt;, Output3Recipe&lt;SimpleInventory&gt; {\n}\n</code></pre> Now implement the methods your IDE (Prefferably Intellij IDEA) asks for, don't create the constructor matching super yet. </p> <p>We need a few fields that will depict how the class works, namely a List for the inputs and 2 ItemStacks for the two outputs we have. Fields<pre><code>private final ItemStack output_1;\nprivate final ItemStack output_2;\nprivate final ItemStack output_3;\n\nprivate final List&lt;Ingredient&gt; recipeItems;\n</code></pre> <p>Now you can hover over the class name, and create the constructor matching super. It should look something like this:</p> <p>Implemented methods<pre><code>public class ExampleRecipe implements Recipe&lt;SimpleInventory&gt;, Output3Recipe&lt;SimpleInventory&gt; {\n\n\n    private final ItemStack output_1;\n    private final ItemStack output_2;\n    private final ItemStack output_3;\n\n    private final List&lt;Ingredient&gt; recipeItems;\n\n    public ExampleRecipe(List&lt;Ingredient&gt; ingredients, ItemStack itemStack, ItemStack output2, ItemStack output3) {\n        this.output_1 = itemStack;\n        this.recipeItems = ingredients;\n        this.output_2 = output2;\n        this.output_3 = output3;\n    }\n\n    @Override\n    public ItemStack getSecondResult(DynamicRegistryManager registryManager) {\n        return null;\n    }\n\n    @Override\n    public ItemStack craftSecond(SimpleInventory inventory, DynamicRegistryManager registryManager) {\n        return null;\n    }\n\n\n    @Override\n    public ItemStack getThirdResult(DynamicRegistryManager registryManager) {\n        return null;\n    }\n\n    @Override\n    public ItemStack craftThird(SimpleInventory inventory, DynamicRegistryManager registryManager) {\n        return null;\n    }\n\n    @Override\n    public boolean matches(SimpleInventory inventory, World world) {\n        return false;\n    }\n\n    @Override\n    public ItemStack craft(SimpleInventory inventory, DynamicRegistryManager registryManager) {\n        return null;\n    }\n\n    @Override\n    public boolean fits(int width, int height) {\n        return false;\n    }\n\n    @Override\n    public ItemStack getResult(DynamicRegistryManager registryManager) {\n        return null;\n    }\n\n    @Override\n    public RecipeSerializer&lt;?&gt; getSerializer() {\n        return null;\n    }\n\n    @Override\n    public RecipeType&lt;?&gt; getType() {\n        return null;\n    }\n}\n</code></pre> Now in the <code>getSecondResult() &amp; craftSecond()</code> methods, return <code>output_2</code>, and <code>getResult() &amp; craft()</code> return <code>output_1</code> <code>getThirdResult() &amp; craftThird()</code> should return <code>output_3</code> The <code>matches()</code> method should look like this:</p> matches()<pre><code>@Override\npublic boolean matches(SimpleInventory inventory, World world) {\n    if(world.isClient()) {\n        return false;\n    }\n\n    return recipeItems.get(0).test(inventory.getStack(0)); //(1)!\n}\n</code></pre> <ol> <li>get(0) can also be replaced with getFirst()</li> </ol> <p>The <code>fits()</code> method should return <code>true</code> Since can't fill in the <code>getSerializer()</code> &amp; <code>getType()</code> methods just yet, remove <code>null;</code> from the return statements to make a deliberate error to help us remember that we need to fill in that method.</p>"},{"location":"mods/more-outputs-api/recipe/three-output-recipe/#recipetype-serializer","title":"RecipeType &amp; Serializer","text":""},{"location":"mods/more-outputs-api/recipe/three-output-recipe/#recipetype","title":"RecipeType","text":"<p>Now we can make the recipe type and recipe serializer, make a new sub class called <code>Type</code> and let it implement <code>RecipeType&lt;ExampleRecipe&gt;</code>. This is a small subclass that only contains two fields: <code>INSTANCE</code> which creates a new instance of the <code>Type</code> class and <code>ID</code> which is the RecipeType ID(entifier)</p> <p>RecipeType<pre><code>public class Type implements RecipeType&lt;ExampleRecipe&gt; {\n\n    public static final Type INSTANCE = new Type();\n    public static final String ID = \"example_recipe\";\n}\n</code></pre> example_recipe can be whatever you want, just make sure its recognizeable.</p>"},{"location":"mods/more-outputs-api/recipe/three-output-recipe/#recipe-serializer","title":"Recipe Serializer","text":"<p>The recipe serializer is a little more complicated but still pretty easy to do. Create another sub class in your class implementing Recipe, ill name it <code>Serializer</code>. <code>Serializer</code> also needs the <code>INSTANCE</code> &amp; <code>ID</code> fields but <code>INSTANCE</code> is equal to <code>new Serializer()</code>.</p> <p>This is what the class should look like: </p> Serializer<pre><code>public static class Serializer implements RecipeSerializer&lt;ExampleRecipe&gt; {\n\n    public static final Serializer INSTANCE = new Serializer();\n    public static final String ID = \"example_recipe\"\n    /*\n    This method is neccessary because of the codec, this is how it works\n    If you have more outputs, duplicate the third or fourth line and adjust it to your needs\n    */  \n    public static final Codec&lt;ExampleRecipe&gt; CODEC = RecordCodecBuilder.create(in -&gt; in.group(\n            validateAmount(Ingredient.DISALLOW_EMPTY_CODEC, 9).fieldOf(\"ingredients\").forGetter(ExampleRecipe::getIngredients),\n            ItemStack.RECIPE_RESULT_CODEC.fieldOf(\"output_1\").forGetter(r -&gt; r.output_1),\n            ItemStack.RECIPE_RESULT_CODEC.fieldOf(\"output_2\").forGetter(r -&gt; r.output_2),\n            ItemStack.RECIPE_RESULT_CODEC.fieldOf(\"output_3\").forGetter(r -&gt; r.output_3)\n        ).apply(in, ExampleRecipe::new));\n\n\n\n\n    private static Codec&lt;List&lt;Ingredient&gt;&gt; validateAmount(Codec&lt;Ingredient&gt; delegate, int max) {\n        return Codecs.validate(Codecs.validate(\n                delegate.listOf(), list -&gt; list.size() &gt; max ? DataResult.error(() -&gt; \"Recipe has too many ingredients!\") : DataResult.success(list)\n        ), list -&gt; list.isEmpty() ? DataResult.error(() -&gt; \"Recipe has no ingredients!\") : DataResult.success(list));\n    }\n\n    @Override\n    public Codec&lt;ExampleRecipe&gt; codec() {\n        return CODEC;\n    }\n\n    @Override\n    public ExampleRecipe read(PacketByteBuf buf) {\n        DefaultedList&lt;Ingredient&gt; inputs = DefaultedList.ofSize(buf.readInt(), Ingredient.EMPTY);\n\n        for(int i = 0; i &lt; inputs.size(); i++) {\n            inputs.set(i, Ingredient.fromPacket(buf));\n        }\n\n        ItemStack output_1 = buf.readItemStack();\n        ItemStack output_2 = buf.readItemStack();\n        ItemStack output_3 = buf.readItemStack();\n        return new ExampleRecipe(inputs, output_1, output_2, output_3);//(1)!\n    }\n\n    @Override\n    public void write(PacketByteBuf buf, ExampleRecipe recipe) {\n        buf.writeInt(recipe.getIngredients().size());\n\n        for (Ingredient ingredient : recipe.getIngredients()) {\n                ingredient.write(buf);\n        }\n\n        buf.writeItemStack(recipe.getResult(null));\n        buf.writeItemStack(recipe.getSecondResult(null));\n        buf.writeItemStack(recipe.getThirdResult(null))\n    }\n}\n</code></pre> <ol> <li>If you have more outputs, declare more ItemStack's like above and add them to the constructor the same way as in the beginning.</li> </ol> <p>Now we can fill in <code>getSerializer()</code> &amp; <code>getType()</code> :</p> <pre><code>@Override\npublic RecipeSerializer&lt;?&gt; getSerializer() {\n    return Serializer.INSTANCE;\n}\n\n@Override\npublic RecipeType&lt;?&gt; getType() {\n    return Type.INSTANCE;\n}\n</code></pre>"},{"location":"mods/more-outputs-api/recipe/three-output-recipe/#registering","title":"Registering","text":"<p>To register the recipes, make a new class in the <code>recipe</code> package, I will call that <code>ModRecipes</code></p> <p>Make a method called <code>registerModRecipes()</code>, it should be a void, in the method add these lines to the method:</p> LinesFull method Registering RecipeType &amp; Serializer<pre><code>    Registry.register(Registries.RECIPE_SERIALIZER, new Identifier(ExampleMod.MOD_ID, ExampleRecipe.Serializer.ID),\n        ExampleRecipe.Serializer.INSTANCE);\n    Registry.register(Registries.RECIPE_TYPE, new Identifier(ExampleMod.MOD_ID, ExampleRecipe.Type.ID),\n        ExampleRecipe.Type.INSTANCE);\n</code></pre> Full method<pre><code>public static void registerRecipes() {\n    Registry.register(Registries.RECIPE_SERIALIZER, new Identifier(ExampleMod.MOD_ID, ExampleRecipe.Serializer.ID),\n            ExampleRecipe.Serializer.INSTANCE);\n    Registry.register(Registries.RECIPE_TYPE, new Identifier(ExampleMod.MOD_ID, ExampleRecipe.Type.ID),\n            ExampleRecipe.Type.INSTANCE);\n}\n</code></pre>"},{"location":"mods/more-outputs-api/recipe/two-output-recipe/","title":"Making a recipe with two outputs","text":"<p>Like already said, we need a class that implements Recipe, Output2Recipe so lets get started. We also need a RecipeType and RecipeSerializer and we need a ModRecipes class."},{"location":"mods/more-outputs-api/recipe/two-output-recipe/#base-recipe-class","title":"Base recipe class","text":"<p>Start by making a new package in your main package called <code>recipe</code>, then create a new class <code>ExampleRecipe</code> and for the type of inventory i will go for is <code>SimpleInventory</code>. </p> <p>ExampleRecipe<pre><code>public class ExampleRecipe implements Recipe&lt;SimpleInventory&gt;, Output2Recipe&lt;SimpleInventory&gt; {\n}\n</code></pre> Now implement the methods your IDE (Prefferably Intellij IDEA) asks for, don't create the constructor matching super yet. </p> <p>We need a few fields that will depict how the class works, namely a List for the inputs and 2 ItemStacks for the two outputs we have. Fields<pre><code>private final ItemStack output_1;\nprivate final ItemStack output_2;\n\nprivate final List&lt;Ingredient&gt; recipeItems;\n</code></pre> <p>Now you can hover over the class name, and create the constructor matching super. It should look something like this:</p> <p>Implemented methods<pre><code>public class ExampleRecipe implements Recipe&lt;SimpleInventory&gt;, Output2Recipe&lt;SimpleInventory&gt; {\n\n\n    private final ItemStack output_1;\n    private final ItemStack output_2;\n\n    private final List&lt;Ingredient&gt; recipeItems;\n\n    public ExampleRecipe(List&lt;Ingredient&gt; ingredients, ItemStack itemStack, ItemStack output2) {\n        this.output_1 = itemStack;\n        this.recipeItems = ingredients;\n        this.output_2 = output2;\n    }\n\n    @Override\n    public ItemStack getSecondResult(DynamicRegistryManager registryManager) {\n        return null;\n    }\n\n    @Override\n    public ItemStack craftSecond(SimpleInventory inventory, DynamicRegistryManager registryManager) {\n        return null;\n    }\n\n    @Override\n    public boolean matches(SimpleInventory inventory, World world) {\n        return false;\n    }\n\n    @Override\n    public ItemStack craft(SimpleInventory inventory, DynamicRegistryManager registryManager) {\n        return null;\n    }\n\n    @Override\n    public boolean fits(int width, int height) {\n        return false;\n    }\n\n    @Override\n    public ItemStack getResult(DynamicRegistryManager registryManager) {\n        return null;\n    }\n\n    @Override\n    public RecipeSerializer&lt;?&gt; getSerializer() {\n        return null;\n    }\n\n    @Override\n    public RecipeType&lt;?&gt; getType() {\n        return null;\n    }\n}\n</code></pre> Now in the <code>getSecondResult() &amp; craftSecond()</code> methods, return <code>output_2</code>, and <code>getResult() &amp; craft()</code> return <code>output_1</code> The <code>matches()</code> method should look like this:</p> matches()<pre><code>@Override\npublic boolean matches(SimpleInventory inventory, World world) {\n    if(world.isClient()) {\n        return false;\n    }\n\n    return recipeItems.get(0).test(inventory.getStack(0)); //(1)!\n}\n</code></pre> <ol> <li>get(0) can also be replaced with getFirst()</li> </ol> <p>The <code>fits()</code> method should return <code>true</code> Since can't fill in the <code>getSerializer()</code> &amp; <code>getType()</code> methods just yet, remove <code>null;</code> from the return statements to make a deliberate error to help us remember that we need to fill in that method.</p>"},{"location":"mods/more-outputs-api/recipe/two-output-recipe/#recipetype-serializer","title":"RecipeType &amp; Serializer","text":""},{"location":"mods/more-outputs-api/recipe/two-output-recipe/#recipetype","title":"RecipeType","text":"<p>Now we can make the recipe type and recipe serializer, make a new sub class called <code>Type</code> and let it implement <code>RecipeType&lt;ExampleRecipe&gt;</code>. This is a small subclass that only contains two fields: <code>INSTANCE</code> which creates a new instance of the <code>Type</code> class and <code>ID</code> which is the RecipeType ID(entifier)</p> <p>RecipeType<pre><code>public class Type implements RecipeType&lt;ExampleRecipe&gt; {\n\n    public static final Type INSTANCE = new Type();\n    public static final String ID = \"example_recipe\";\n}\n</code></pre> example_recipe can be whatever you want, just make sure its recognizeable.</p>"},{"location":"mods/more-outputs-api/recipe/two-output-recipe/#recipe-serializer","title":"Recipe Serializer","text":"<p>The recipe serializer is a little more complicated but still pretty easy to do. Create another sub class in your class implementing Recipe, ill name it <code>Serializer</code>. <code>Serializer</code> also needs the <code>INSTANCE</code> &amp; <code>ID</code> fields but <code>INSTANCE</code> is equal to <code>new Serializer()</code>.</p> <p>This is what the class should look like: </p> Serializer<pre><code>public static class Serializer implements RecipeSerializer&lt;ExampleRecipe&gt; {\n\n    public static final Serializer INSTANCE = new Serializer();\n    public static final String ID = \"example_recipe\"\n    /*\n    This method is neccessary because of the codec, this is how it works\n    If you have more outputs, duplicate the third or fourth line and adjust it to your needs\n    */  \n    public static final Codec&lt;ExampleRecipe&gt; CODEC = RecordCodecBuilder.create(in -&gt; in.group(\n            validateAmount(Ingredient.DISALLOW_EMPTY_CODEC, 9).fieldOf(\"ingredients\").forGetter(ExampleRecipe::getIngredients),\n            ItemStack.RECIPE_RESULT_CODEC.fieldOf(\"output_1\").forGetter(r -&gt; r.output_1),\n            ItemStack.RECIPE_RESULT_CODEC.fieldOf(\"output_2\").forGetter(r -&gt; r.output_2)\n        ).apply(in, ExampleRecipe::new));\n\n\n\n\n    private static Codec&lt;List&lt;Ingredient&gt;&gt; validateAmount(Codec&lt;Ingredient&gt; delegate, int max) {\n        return Codecs.validate(Codecs.validate(\n                delegate.listOf(), list -&gt; list.size() &gt; max ? DataResult.error(() -&gt; \"Recipe has too many ingredients!\") : DataResult.success(list)\n        ), list -&gt; list.isEmpty() ? DataResult.error(() -&gt; \"Recipe has no ingredients!\") : DataResult.success(list));\n    }\n\n    @Override\n    public Codec&lt;ExampleRecipe&gt; codec() {\n        return CODEC;\n    }\n\n    @Override\n    public ExampleRecipe read(PacketByteBuf buf) {\n        DefaultedList&lt;Ingredient&gt; inputs = DefaultedList.ofSize(buf.readInt(), Ingredient.EMPTY);\n\n        for(int i = 0; i &lt; inputs.size(); i++) {\n            inputs.set(i, Ingredient.fromPacket(buf));\n        }\n\n        ItemStack output_1 = buf.readItemStack();\n        ItemStack output_2 = buf.readItemStack();\n        return new ExampleRecipe(inputs, output_1, output_2);//(1)!\n    }\n\n    @Override\n    public void write(PacketByteBuf buf, ExampleRecipe recipe) {\n        buf.writeInt(recipe.getIngredients().size());\n\n        for (Ingredient ingredient : recipe.getIngredients()) {\n                ingredient.write(buf);\n        }\n\n        buf.writeItemStack(recipe.getResult(null));\n        buf.writeItemStack(recipe.getSecondResult(null));\n    }\n}\n</code></pre> <ol> <li>If you have more outputs, declare more ItemStack's like above and add them to the constructor the same way as in the beginning.</li> </ol> <p>Now we can fill in <code>getSerializer()</code> &amp; <code>getType()</code> :</p> <pre><code>@Override\npublic RecipeSerializer&lt;?&gt; getSerializer() {\n    return Serializer.INSTANCE;\n}\n\n@Override\npublic RecipeType&lt;?&gt; getType() {\n    return Type.INSTANCE;\n}\n</code></pre>"},{"location":"mods/more-outputs-api/recipe/two-output-recipe/#registering","title":"Registering","text":"<p>To register the recipes, make a new class in the <code>recipe</code> package, I will call that <code>ModRecipes</code></p> <p>Make a method called <code>registerModRecipes()</code>, it should be a void, in the method add these lines to the method:</p> LinesFull method Registering RecipeType &amp; Serializer<pre><code>    Registry.register(Registries.RECIPE_SERIALIZER, new Identifier(ExampleMod.MOD_ID, ExampleRecipe.Serializer.ID),\n        ExampleRecipe.Serializer.INSTANCE);\n    Registry.register(Registries.RECIPE_TYPE, new Identifier(ExampleMod.MOD_ID, ExampleRecipe.Type.ID),\n        ExampleRecipe.Type.INSTANCE);\n</code></pre> Full method<pre><code>public static void registerRecipes() {\n    Registry.register(Registries.RECIPE_SERIALIZER, new Identifier(ExampleMod.MOD_ID, ExampleRecipe.Serializer.ID),\n            ExampleRecipe.Serializer.INSTANCE);\n    Registry.register(Registries.RECIPE_TYPE, new Identifier(ExampleMod.MOD_ID, ExampleRecipe.Type.ID),\n            ExampleRecipe.Type.INSTANCE);\n}\n</code></pre>"},{"location":"mods/more-outputs-api/screen/","title":"Screen (handlers)","text":"<p>We need a few things, </p> <ul> <li>A class that will register the screen handlers (ModScreenHandlers)</li> <li>A screen</li> <li>A screenhandler</li> </ul>"},{"location":"mods/more-outputs-api/screen/#modscreenhandlers","title":"ModScreenHandlers","text":"<p>In the main package, create a new package called <code>screen</code>, then create a new class I will call <code>ModScreenHandlers</code>. In that class, create a new void method called <code>registerModScreenHandlers</code>. Note: This class will have errors at first but once we create the screen(handlers), they will all go away. The method should look like this:</p> <pre><code>public static final ScreenHandlerType&lt;ExampleScreenHandler&gt; EXAMPLE_SCREEN_HANDLER =\n    Registry.register(Registries.SCREEN_HANDLER, new Identifier(ExampleMod.MOD_ID, \"example\"),\n            new ExtendedScreenHandlerType&lt;&gt;(ExampleScreenHandler::new));\n\npublic static void registerScreenHandlers() {\n    ExampleMod.LOGGER.info(\"Registering Screen Handlers for \" + ExampleMod.MOD_ID);//(1)!\n}\n</code></pre> <ol> <li>This can be empty and is recommended to be empty</li> </ol> <p>Now we can create a screen and a screenhandler. </p>"},{"location":"mods/more-outputs-api/screen/examplescreen/","title":"Screen","text":""},{"location":"mods/more-outputs-api/screen/examplescreen/#prerequisites","title":"Prerequisites","text":"<p>Before we can get started, we need to have a class implementing <code>HandledScreen</code> of type <code>ExampleScreenHandler</code>. In action it would look a bit like this:</p> Initial screen<pre><code>public class ExampleScreen extends HandledScreen&lt;ExampleScreenHandler&gt; {\n}\n</code></pre> <p>Then we need a field which is the texture of your gui. Mine looks like this:</p> <p></p> <p><pre><code>private static final Identifier TEXTURE = new Identifier(ExampleMod.MOD_ID, \"textures/gui/example_gui.png\");\n</code></pre> This points to the <code>resources/assets/MOD_ID/textures/gui/example_gui.png</code> file.</p> <p>You can see the progress arrow already! Now you can implement everything your IDE asks for including the constructor matching super.</p>"},{"location":"mods/more-outputs-api/screen/examplescreen/#required-methods","title":"Required Methods","text":""},{"location":"mods/more-outputs-api/screen/examplescreen/#init","title":"init()","text":"<pre><code>@Override\nprotected void init() {\n    super.init();\n    titleY = 1000;//(1)!\n    playerInventoryTitleY = 1000;//(2)!\n}\n</code></pre> <ol> <li>This is the height of the title the block entity screen has, like you would see with vanilla block entities such as a furnace</li> <li>This is the height of the title of your inventory that says <code>`Inventory</code></li> </ol>"},{"location":"mods/more-outputs-api/screen/examplescreen/#drawbackground","title":"drawBackGround()","text":"<pre><code>@Override\nprotected void drawBackground(DrawContext context, float delta, int mouseX, int mouseY) {\n    RenderSystem.setShader(GameRenderer::getPositionTexProgram);\n    RenderSystem.setShaderColor(1f, 1f, 1f, 1f);\n    RenderSystem.setShaderTexture(0, TEXTURE);\n    int x = (width - backgroundWidth) / 2;\n    int y = (height - backgroundHeight) / 2;\n\n    context.drawTexture(TEXTURE, x, y, 0, 0, backgroundWidth, backgroundHeight);\n\n    renderProgressArrow(context, x, y);\n}\n</code></pre>"},{"location":"mods/more-outputs-api/screen/examplescreen/#render","title":"render()","text":"<pre><code>@Override\npublic void render(DrawContext context, int mouseX, int mouseY, float delta) {\n    renderBackground(context, mouseX, mouseY, delta);\n    super.render(context, mouseX, mouseY, delta);\n    drawMouseoverTooltip(context, mouseX, mouseY);\n}\n</code></pre>"},{"location":"mods/more-outputs-api/screen/examplescreen/#non-required-but-recommended-methods","title":"Non-required but recommended methods","text":""},{"location":"mods/more-outputs-api/screen/examplescreen/#renderprogressarrow","title":"renderProgressArrow()","text":"<pre><code>private void renderProgressArrow(DrawContext context, int x, int y) {\n    if(handler.isCrafting()) {\n        context.drawTexture(TEXTURE, x + 85, y + 30, 176, 0, 8, handler.getScaledProgress());\n    }\n}\n</code></pre>"},{"location":"mods/more-outputs-api/screen/examplescreen/#finishing-up","title":"Finishing up","text":"<p>Now we can do the final things to complete our multiple output block entity!</p> <p>Finishing up</p>"},{"location":"mods/more-outputs-api/screen/examplescreenhandler/","title":"Screen","text":""},{"location":"mods/more-outputs-api/screen/examplescreenhandler/#prerequisites","title":"Prerequisites","text":"<p>For the screen handler, we need a class extending <code>ScreenHandler</code>. In action it would look like this:</p> ExampleScreenHandler empty<pre><code>public class ExampleScreenHandler extends ScreenHandler {\n\n}\n</code></pre> <p>Your IDE will now ask for a few methods, hover over the class (above) and implement the methods asked for but don't create the constructor matching super yet. We are going to do that manually.</p> <p>But first, we need a few fields:</p> Fields<pre><code>private final Inventory inventory;//(1)!\nprivate final PropertyDelegate propertyDelegate;\npublic final ExampleBlockEntity blockEntity;//(2)!\n</code></pre> <ol> <li>This is the inventory that represents the block entity inventory</li> <li>This is the actual block entity</li> </ol>"},{"location":"mods/more-outputs-api/screen/examplescreenhandler/#constructors-matching-super","title":"Constructors (matching super)","text":"<p>Now we can actually create the what is really two constructors so lets go!</p> 2 Constructors<pre><code>public ExampleScreenHandler(int syncId, PlayerInventory inventory, PacketByteBuf buf) {\n    this(syncId, inventory, inventory.player.getWorld().getBlockEntity(buf.readBlockPos()),\n            new ArrayPropertyDelegate(3));//(1)!\n}\n\n\npublic ExampleScreenHandler(int syncId, PlayerInventory playerInventory,\n                                BlockEntity blockEntity, PropertyDelegate arrayPropertyDelegate) {\n    super(ModScreenHandlers.EXAMPLE_SCREEN_HANDLER, syncId);\n    checkSize(((Inventory) blockEntity), 2);\n\n    this.inventory = ((Inventory) blockEntity);\n    inventory.onOpen(playerInventory.player);\n    this.propertyDelegate = arrayPropertyDelegate;\n    this.blockEntity = ((ExampleBlockEntity) blockEntity);\n\n    this.addSlot(new Slot(inventory, 0, 80, 11));\n    this.addSlot(new Slot(inventory, 1, 62, 59));\n    this.addSlot(new Slot(inventory, 2, 98,59));\n\n    //If you have more slots, add them here\n\n    /* 3rd output slot\n    this.addSlot(new Slot(inventory, 3, x ,y));\n    */\n\n   /* 4th output slot\n   this.addSlot(new Slot(invenotry, 4, x, y));\n   */\n   //(2)!\n    addPlayerInventory(playerInventory);\n    addPlayerHotbar(playerInventory);\n\n    addProperties(arrayPropertyDelegate);\n}\n</code></pre> <ol> <li>This is also how big your inventory is, just like in the block entity class. This should match the sizes specified in your block entity. For two outputs it is 3, for three outputs it is 4 and for 4 outputs it is 5 because we also have an input slot.</li> <li>From here, there are a few errors because we haven't created those methods yet.</li> </ol>"},{"location":"mods/more-outputs-api/screen/examplescreenhandler/#required-methods","title":"Required methods","text":"<p>The methods that are absolutely required, are the following:</p> <p>Required methods<pre><code>@Override\npublic ItemStack quickMove(PlayerEntity player, int invSlot) {\n    ItemStack newStack = ItemStack.EMPTY;\n    Slot slot = this.slots.get(invSlot);\n    if (slot != null &amp;&amp; slot.hasStack()) {\n        ItemStack originalStack = slot.getStack();\n        newStack = originalStack.copy();\n        if (invSlot &lt; this.inventory.size()) {\n            if (!this.insertItem(originalStack, this.inventory.size(), this.slots.size(), true)) {\n                return ItemStack.EMPTY;\n            }\n        } else if (!this.insertItem(originalStack, 0, this.inventory.size(), false)) {\n            return ItemStack.EMPTY;\n        }\n\n        if (originalStack.isEmpty()) {\n            slot.setStack(ItemStack.EMPTY);\n        } else {\n            slot.markDirty();\n        }\n    }\n\n    return newStack;\n}\n\n@Override\npublic boolean canUse(PlayerEntity player) {\n    return this.inventory.canPlayerUse(player);\n}\n\nprivate void addPlayerInventory(PlayerInventory playerInventory) {\n    for (int i = 0; i &lt; 3; ++i) {\n        for (int l = 0; l &lt; 9; ++l) {\n            this.addSlot(new Slot(playerInventory, l + i * 9 + 9, 8 + l * 18, 84 + i * 18));\n        }\n    }\n}\n\nprivate void addPlayerHotbar(PlayerInventory playerInventory) {\n    for (int i = 0; i &lt; 9; ++i) {\n        this.addSlot(new Slot(playerInventory, i, 8 + i * 18, 142));\n    }\n}\n</code></pre> This will make sure your hotbar and inventory will be visible from the inventory of our block entity. It loops through every slot you have and adds that slot on a certain position.</p>"},{"location":"mods/more-outputs-api/screen/examplescreenhandler/#non-required-but-recommended-methods","title":"Non-required but recommended methods","text":"<p>These two methods will help render a progress arrow for your recipe, it will be a nice thing for players to have.</p> Progress arrow methods<pre><code>public boolean isCrafting() {\n    return propertyDelegate.get(0) &gt; 0;\n}\n\npublic int getScaledProgress() {\n    int progress = this.propertyDelegate.get(0);\n    int maxProgress = this.propertyDelegate.get(1);  // Max Progress\n    int progressArrowSize = 26; // This is the width in pixels of your arrow\n\n    return maxProgress != 0 &amp;&amp; progress != 0 ? progress * progressArrowSize / maxProgress : 0;\n}\n</code></pre> <p>Now we can create the actual screen!</p> <p>ExampleScreen</p>"},{"location":"plugins/","title":"All available plugins","text":""},{"location":"plugins/#standalone-plugins","title":"Standalone plugins","text":""},{"location":"plugins/#minibosses","title":"MiniBosses","text":""},{"location":"plugins/#library-plugins","title":"Library plugins","text":""},{"location":"plugins/#subcommandlib","title":"SubCommandLib","text":"<p>SubCommandLib is an easy to use development library aimed to help developers make subcommands faster and better.  Click here to get started (or on the header above) with SubCommandLib.</p> <p>Features:</p> <ul> <li>Completely customizeable by overriding methods</li> <li>The ability to choose between tabcompletion and no tab completion</li> </ul> <p>Credits:</p> <p>All credits go to @KodySimpson on youtube for providing the code. I turned it into a library for developers to use</p>"},{"location":"plugins/subcommandlib/","title":"SubCommandLib","text":""},{"location":"plugins/subcommandlib/#getting-started","title":"Getting started","text":"<p>What are subcommands you might ask? Subcommands are commands that are registered after a main, central command. Think of them as arguments of a command that are a commands themselves. Ex: <code>/deluxehub reload</code></p> <p>To get started with subcommand lib you need to either do 1 or 2 depending on your build system:</p> GradleMaven In your build.gradle<pre><code>//This should be at the top repository block\nmaven {\nurl \"https://repo.repsy.io/mvn/scaredrabbit/scaredsplugins\"\n}\n\n//This should be in the dependencies block of your build.gradle\nmodImplementation \"io.github.scaredsplugins:SubCommandLib:${project.subcommandlib_version}\"\n</code></pre> <p>In your gradle.properties<pre><code>subcommandlib_version = VERSION\n</code></pre> Note: <pre><code>${project.subcommandlib_version}\n</code></pre> Is completely optional and is not neccessary at all, just for convenience of easier version swapping.</p> <p><pre><code>&lt;repository&gt;\n    &lt;id&gt;repsy&lt;/id&gt;\n    &lt;url&gt;https://repo.repsy.io/mvn/scaredrabbit/scaredsmods&lt;/url&gt;\n&lt;/repository&gt;\n</code></pre> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.github.scaredsplugins&lt;/groupId&gt;\n    &lt;artifactId&gt;SubCommandLib&lt;/artifactId&gt;\n    &lt;version&gt;VERSION&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre></p> <p><code>VERSION</code> &amp; ```can either be found on curseforge or on repsy</p>"},{"location":"plugins/subcommandlib/#adding-subcommands","title":"Adding Subcommands","text":"<p>To do that, we need to do a few things:</p> <ul> <li>Make a custom manager class</li> <li>Make a class extending subcommand</li> <li>Register the command &amp; main command</li> </ul>"},{"location":"plugins/subcommandlib/manager/","title":"Making a custom manager class","text":"<p>Before you can add a subcommand, you need to have a central manager that collects all subcommmands Create a new class and let it extend either extends <code>CommandManager</code> or <code>TabCompletionCommandManager</code>. The difference is that <code>TabCompletionCommandManager</code> subcommands are visible when typing them in the chat.  Create a new, empty constructor.</p> <pre><code>public class ExampleManager extends TabCompletionCommandManager {\n\n    public ExampleManager() {\n\n    }\n}\n</code></pre> <p>If you want to make custom logic for the <code>onTabComplete()</code> &amp; <code>onCommand()</code> methods, which are required to work, override them to apply that code to my code.</p>"},{"location":"plugins/subcommandlib/registering/","title":"Registering","text":""},{"location":"plugins/subcommandlib/registering/#registering-the-main-command","title":"Registering the main command","text":"<p>The last two things you need to is:</p> <ol> <li> <p>Register the subcommand to the Manager class</p> </li> <li> <p>Register the main command</p> </li> </ol> <p>To register the subcommand to the command, return to the class you created at the beginning. In the constructor add this:</p> <p><pre><code>getSubCommands().add(new ExampleCommand());\n</code></pre> The manager class should look a bit like this:</p> <p><pre><code>public class ExampleManager extends TabCompletionCommandManager {\n\n    public ExampleManager() {\n        getSubCommands().add(new ExampleCommand());\n        [... Any other subcommands ...]\n    }\n}\n</code></pre> <code>getSubCommands()</code> is a method that returns a ArrayList and adds them to the <code>TabCompletionCommandManager</code> because we extend from that class.  <p>To register the main command, go to the class that extends <code>JavaPlugin</code>. In the <code>onEnable()</code> method, you should add <code>getCommand(\"example\").setExecutor(new SomeManager());</code>.</p> <ul> <li>example should be the first command you type in. Ex.: <code>/dhub</code></li> <li>by doing <code>new SomeManager()</code> we simply say: Hey server, here you have a class that can execute multiple commands. As specified above, in the constructor the subcommands are added to the constructor. So by calling the constructor, you basically say that all the subcommands should be added alongside the main command.</li> </ul> <p>The last to do will be adding the command to the <code>plugin.yml</code> file Go to <code>resources/plugin.yml</code>, and add this (you probably already know this, and should know it):</p> <p><pre><code>commands:\n  example:\n    description: Example\n</code></pre> <code>example</code> should be the string you provided in <code>onEnable()</code></p>"},{"location":"plugins/subcommandlib/registering/#finishing-up","title":"Finishing up","text":"<p>Repeat these steps for more subcommands</p> <p>Have a question? You are allowed to ask questions in the issues of the github repository. Or DM me on discord, my username is <code>scaredrabbitnl_</code></p>"},{"location":"plugins/subcommandlib/subcommands/","title":"Adding Subcommands","text":""},{"location":"plugins/subcommandlib/subcommands/#making-new-subcommands","title":"Making new subcommands","text":"<p>Then create a new class <code>SomeCommand.java</code> and make it extend <code>SubCommand</code>. Implement all the neccessary methods your IDE asks for. It should look something like this:</p> <p><pre><code>import io.github.scaredsplugins.subcommandlib.api.command.SubCommand;\nimport org.bukkit.entity.Player;\n\nimport java.util.List;\n\npublic class ExampleCommand extends SubCommand {\n    @Override\n    public String getName() {\n        return \"example\";\n    }\n\n    @Override\n    public String getDescription() {\n        return \"This is an example!\";\n    }\n\n    @Override\n    public String getSyntax() {\n        return \"/exampleplugin example &lt;your-provided-subcommand-arguments&gt;\";\n    }\n\n    @Override\n    public void perform(Player player, String[] strings) {\n\n        player.sendMessage(\"This is an example!\")\n    }\n\n    @Override\n    public List&lt;String&gt; getSubcommandArguments(Player player, String[] strings) {\n        return null;\n    }\n}\n</code></pre> Remember that the default return value of <code>getSubcommandArguments(Player, player, String[] strings)</code> is <code>List.of()</code>. If you don't plan on adding arguments for the subcommands, let <code>getSubcommandArguments(Player, player, String[] strings)</code> return <code>null</code>.</p> <ul> <li>The <code>getName()</code> should return a string containing the name of your *subcommand*</li> <li>The <code>getDescription()</code> is the description of the command that will appear when doing /help</li> <li>The <code>getSyntax()</code> method is what you get sent in chat when entering the command wrong or when doing /help. Generally: How the command should be used.</li> <li>The <code>perform()</code> method is what will be executed when the subcommand is run. For example: <code>/example reload</code> reloads the <code>example</code> plugin configs.</li> </ul>"},{"location":"version-schemes/","title":"Version schemes","text":"<p>Why do this? I made general version schemes for both plugins and mods because I want players and developers to know exactly how my projects are versioned.</p>"},{"location":"version-schemes/mod/","title":"Mod version schemes","text":""},{"location":"version-schemes/mod/#version-schemes-for-the-mods","title":"Version schemes for the mods","text":"<p>Note: it isnt worth backporting to version prior to 1.18 and certainly not prior to 1.14 so those versions won't be backported. All my mods follow this general version scheme. If it is different for some mod, it will be listed at their page.</p> Minecraft Version Mod Version Mod Loader &lt; 1.18 - - 1.18.x 0.2.x Fabric as default 1.19.x 0.5.x Fabric as default 1.20.x 1.x.x Fabric as default 1.21.x 2.x.x Fabric as default"},{"location":"version-schemes/plugin/","title":"Plugin version schemes","text":""},{"location":"version-schemes/plugin/#version-schemes-for-the-plugins","title":"Version schemes for the plugins","text":"<p>Plugins are mostly compatible with older versions, or future versions. Any changes required will be listed</p> Minecraft Version Plugin version &lt; 1.18 legacy, not supported but probably possible 1.18 0.2.x 1.19 0.5.x 1.20 1.0.x 1.21 2.0.x"}]}